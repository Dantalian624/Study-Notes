## 一期上



### 做项目的流程

1. 项目介绍、项目调研、需求分析

2. 核心业务流程

3. 项目要做的功能（功能模块）

4. 技术选型（技术预研）

5. 项目初始化

6. 项目开发

7. 测试

8. 优化

9. 代码提交、代码审核

10. 产品验收

11. 上线



写文档、持续调研、持续记录总结



### 现有系统调研

[HimitZH/HOJ: ⚡🔥Hcode Online Judge(HOJ)🔥⚡：基于SpringCloud与Vue前后端分离，分布式架构的在线测评平台OJ (An open source online judge system base on SpringBoot, Springcloud Alibaba and Vue.js !) (github.com)](https://github.com/HimitZH/HOJ)



### OJ系统的常用概念

ac表示你的题目通过，结果正确

题目限制：时间限制、内存限制

题目介绍

题目输入

题目输出

题目输入用例

题目输出用例

 

普通测评：管理员设置题目的输入和输出用例，比如我输入1，你要输出2才是正确的；交给判题机去执行用户的代码，给用户的代码输入用例，比如1，看用户程序的执行结果是否和标准答案的输出一致。（比对用例文件）

特殊测评（SPJ）：管理员设置题目的输入和输出用例，比如我输入1，用户的答案只要是 >0 或 <2 都是正确的；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题目写一个特殊的判断程序，程序接收题目的输入（1）、标准输出用例（2）、用户的结果（1.5），特判程序根据这些值来比较是否正确。

交互测评：让用户输入一个例子，就给出一个输出结果，交互比较灵活，没办法通过简单的、死板的输入输出文件来确定。

 

不能让用户随便引入包、随便遍历、暴力破解，需要使用正确的算法 --> 安全性

判断过程是异步的 --> 异步化

提交之后会生成一个提交记录，有运行的结果以及运行信息（时间限制、内存限制）



### 功能

1. 题目浏览
   1. 创建题目（管理员）
   2. 删除题目（管理员）
   3. 修改题目（管理员）
   4. 搜索题目（用户）
   5. 在线做题（用户）
   6. 提交题目代码（用户）
2. 用户模块
   1. 注册
   2. 登录
3. 判题模块
   1. 提交判题（结果是否正确与错误）
   2. 错误处理（内存溢出、安全性、超时）
   3. 自主实现 代码沙箱（安全沙箱）
   4. 开放接口（提供一个独立的新服务）



### 项目拓展思路

1. 支持多种语言
2. Remote Judge
3. 完善的评测功能：普通测评、特殊测评、交互测评、在线自测、子任务分组评测、文件IO



### 技术选型

前端：Vue3、Arco Design组件库、手撸项目模板、在线代码编辑器、在线文档浏览

Java进程控制、Java安全管理器、部分JVM知识点

虚拟机（云服务器）、Docker（代码沙箱实现）

Spring Cloud微服务、消息队列



### 实现核心

（1）权限校验

谁能提代码，谁不能提代码

 

（2）代码沙箱

用户代码藏毒：写个木马文件、修改系统权限

沙箱：隔离的、安全的环境，用户的代码不会影响到沙箱之外的系统的运行

资源分配：系统内存就2G，用户疯狂占用资源占满你的内存，其他人就用不了了，所以要限制用户程序的占用资源。

 

（3）判题规则

题目用例的比对，结果的验证

 

（4）任务调度

服务器资源有限，用户要排队，按照顺序依次执行判题，而不是直接拒绝



### 核心业务流程

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240829170413207.png" alt="image-20240829170413207" style="zoom:50%;" />

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240829170514359.png" alt="image-20240829170514359" style="zoom: 50%;" />

判题服务：获取题目信息、预计的输入输出结果，返回给主业务后端；用户的答案是否正确

代码沙箱：只负责运行代码，给出结果，不管什么结果是正确的



### 架构设计

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240829170553782.png" alt="image-20240829170553782" style="zoom:50%;" />

### 主流的OJ系统实现方案

开发原则：能用别人的就不要自己写

1. 用现成的OJ系统，比如 judge0

<https://github.com/judge0/judge0>

自己用源码来部署、公有云、私有云

 

1. 用现成的判题API（比如judge0），现成的判题沙箱

<https://rapidapi.com/nl/judge0-official/api/judge0-ce/>

 

API的作用：接受代码、返回执行结果

注册、开通订阅、测试Languages接口、测试执行代码接口submissions

官方文档 <https://ce.judge0.com/#submissions-submission-post>

 

示例接口参数：

```json
{
 "source_code": "#include <stdio.h>\n\nint main(void) {\n char name[10];\n scanf(\"%s\", name);\n printf(\"hello, %s\n\", name);\n return 0;\n}",
 "language_id": "4",
 "stdin": "Judge0",
 "expected_output": "hello, Judge0"
}
 
```

预期返回：

```json
{
 "source_code": "includestdiohintmainvoidcharname10scanfsnameprintfhellosnamereturn0=",
 "language_id": 76,
 "stdin": "Judgew==",
 "expected_output": "helloJudge0=",
 "stdout": null,
 "status_id": 6,
 "created_at": "2024-07-09T13:40:07.064Z",
 "finished_at": "2024-07-09T13:40:07.731Z",
 "time": null,
 "memory": null,
 "stderr": null,
 "token": "9f51b37c-45fe-42f6-9ce1-3a80b6feaafe",
 "number_of_runs": 1,
 "cpu_time_limit": "5.0",
 "cpu_extra_time": "1.0",
 "wall_time_limit": "10.0",
 "memory_limit": 128000,
 "stack_limit": 64000,
 "max_processes_and_or_threads": 60,
 "enable_per_process_and_thread_time_limit": false,
 "enable_per_process_and_thread_memory_limit": false,
 "max_file_size": 1024,
 "compile_output": "……",
 "exit_code": null,
 "exit_signal": null,
 "message": null,
 "wall_time": null,
 "compiler_options": null,
 "command_line_arguments": null,
 "redirect_stderr_to_stdout": false,
 "callback_url": null,
 "additional_files": null,
 "enable_network": false,
 "post_execution_filesystem": null,
 "status": {
  "id": 6,
  "description": "Compilation Error"
 },
 "language": {
  "id": 76,
  "name": "C++ (Clang 7.0.1)"
 }
}
```





### 前端项目初始化

环境： node v18.20.4、npm 10.7.0

 

初始化：

使用vue-cli脚手架： <https://next.cli.vuejs.org/>

安装脚手架工具： npm install -g @vue/cli

检测是否安装成功： vue -V

创建项目： vue create oj_frontend

运行项目



### 前端工程化配置

脚手架已经为我们配置了代码美化、自动校验、格式化插件等，无需再自行配置



### 全局状态管理

Vuex: [开始 | Vuex (vuejs.org)](https://vuex.vuejs.org/zh/guide/)

所有页面全局共享的变量，而不是局限在某一个页面中。

适合作为全局状态的数据：已登录用户信息

本质上：提供了一套增删改查全局变量的API，只不过可能多了一些功能（比如时间旅行）

 <img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240829171006758.png" alt="image-20240829171006758" style="zoom:50%;" />



可以直接参考购物车示例：[vuex/examples/classic/shopping-cart at main · vuejs/vuex (github.com)](https://github.com/vuejs/vuex/tree/main/examples/classic/shopping-cart)

 

state：存储的状态信息，比如用户信息

mutation（尽量同步）：定义了对变量进行增删改查（更新）的方法

actions（支持异步）：执行异步操作，并且触发 mutation 的更改（actions 调用 mutation）

 

先定义 user 模块：

user.ts：

``` ts
import { StoreOptions } from "vuex";

export default {
  namespaced: true,
  state: () => ({
    loginUser: {
      userName: "未登录",
    },
  }),

  actions: {
    getLoginUser({ commit, state }, payload) {
      commit("setProducts", { userName: "Dan" });
    },
  },

  mutations: {
    updateUser(state, payload) {
      state.loginUser = payload;
    },
  },
} as StoreOptions<any>;
```



index.ts：

```ts
import { createStore } from "vuex";

import user from "./user";

export default createStore({
  mutations: {},

  actions: {},

  modules: {
    user,
  },
});
```

 

获取状态变量：

`const store = useStore();`

`store.state.user.loginUser`

 

修改状态变量：

```ts
store.dispatch("user/getLoginUser", {
  userName: "Dan",
});
```



### 实现通用菜单

[Arco Design Vue](https://arco.design/vue/component/menu)

把菜单上的路由改成读取路由文件，实现更通用的动态配置

 

(1) 提取通用路由文件

(2) 菜单组件读取路由，动态渲染菜单项

(3) 绑定跳转事件

(4) 同步路由到菜单项

 

首先点击菜单项 > 跳转更新路由 > 更新路由后，同步去更新菜单栏的高亮状态

```ts
const router = useRouter();
//默认主页
const selectedKeys = ref(["/"]);

//路由跳转时，更新选中的菜单项
router.afterEach((to, from, failure) => {
  selectedKeys.value = [to.path];
});
```



### 权限管理

我能够直接以一套通用的机制，去定义哪个页面需要哪些权限。



思路：

（1）在路由配置文件，定义某个路由的访问权限

（2）在全局页面组件中，绑定一个全局路由监听。每次访问页面时，根据用户要访问页面的路由信息，先判断用户是否有访问权限

（3）如果有，跳转到原页面；如果没有，拦截或跳转到401鉴权或登录页



可以单独定义一个文件，控制路由的显影



## 一期下

1. 完善前端通用项目的模板
2. 后端项目初始化（万用模板）
3. 前端接口调用代码的自动生成（通用的一个代码生成插件）
4. 前后端联调
5. 快速写一遍登录注册页




### 优化页面布局

1. 底部 footer 布局优化
2. 优化 content、globalHeader 的样式
3. 优化导航栏用户名称的换行




### 通用导航栏组件，根据配置控制菜单的显隐

```ts
{
    path: "/hide",
    name: "隐藏页面",
    component: AdminView,
    meta: {
      hideInMenu: true,
    },
},
```

```vue,ts
const visibleRoutes = routes.filter((item, index) => {
  if (item.meta?.hideInMenu) {
    return false;
  }
  return true;
});

<a-menu-item v-for="item in visibleRoutes" :key="item.path">
    {{item.name}}
</a-menu-item>
```



### 根据权限隐藏

需求： 只有具有权限的菜单，才对用户可见
原理：类似上面的控制路由显示隐藏，只要判断用户没有权限就过滤掉



### 全局权限管理

1）定义权限

```ts
/**
 * 权限定义
 */
const ACCESS_ENUM = {
  NOT_LOGIN: "notLogin",
  USER: "user",
  ADMIN: "admin",
};

export default ACCESS_ENUM;
```

2）定义一个公用的权限校验方法
因为菜单组件要判断权限，权限拦截也要用到权限判断功能，所以抽离成公共方法

创建checkAccess.ts文件，专门定义检测权限的函数：

```ts
import ACCESS_ENUM from "./accessEnum";

/**
 * 检查权限 （判断当前登录用户是否具有某个权限）
 * @param loginUser 当前登录用户
 * @param needAccess 需要有的权限
 * @return boolean 有无权限
 */
const checkAccess = (loginUser: any, needAccess = ACCESS_ENUM.NOT_LOGIN) => {
  //获取当前登录用户具有的权限（如果没有loginUser，则表示未登录）
  const loginUserAccess = loginUser?.userRole ?? ACCESS_ENUM.NOT_LOGIN;
  if (needAccess === ACCESS_ENUM.NOT_LOGIN) {
    return true;
  }
  //如果用户登录才能访问
  if (needAccess === ACCESS_ENUM.USER) {
    //如果用户没登陆，那么表示无权限
    if (loginUserAccess !== ACCESS_ENUM.NOT_LOGIN) {
      return false;
    }
  }
  //如果需要管理员权限
  if (needAccess === ACCESS_ENUM.ADMIN) {
    //如果不为管理员，表示无权限
    if (loginUserAccess !== ACCESS_ENUM.ADMIN) {
      return false;
    }
  }
  return true;
};

export default checkAccess;
```

3）修改 GlobalHeader 动态菜单组件，根据权限来过滤菜单
注意，这里使用计算属性，是为了当登录用户信息发生变更时，触发菜单栏的重新渲染，展示新增权限的菜单项

```ts
const visibleRoutes = computed(() => {
  return routes.filter((item, index) => {
    if (item.meta?.hideInMenu) {
      return false;
    }
    // 根据权限过滤菜单
    if (
      !checkAccess(store.state.user.loginUser, item?.meta?.access as string)
    ) {
      return false;
    }
    return true;
  });
});
```



### 全局项目入口

app.vue 中预留一个可以编写全局初始化逻辑的代码：

```ts
const doInit = () => {
  console.log("hello 欢迎来到我的项目");
};
onMounted(() => {
  doInit();
});
```



### 后端项目初始化

把通用后端框架运行

1）打开 springboot-init 后端项目模板
2）全局替换项目名称（oj-backend）
3）全局替换包名（dantalian.danoj）
4）执行 create_table.sql 脚本，修改数据库名（danoj）
5）修改端口号
6）修改 application.yml 中的数据库配置



### 项目模板

1）README.md
2）sql/create_table.sql 定义了数据库的初始化建库建表语句
3）sql/post_es_mapping.json 帖子表在 ES 中的建表命令
4）aop 拥有全局权限校验、全局日志记录
5）common 万用类，比如通用响应类
6）config 拥有接收 application.yml 中的参数，初始化一些客户端的配置类（比如对象客户存储客户端）
7）constant 定义常量
8）controller 接收请求
9）esdao 类似 mybatis 的 mapper，用于操作 ES
10）exception 异常处理相关
11）job 任务相关（定时任务、单次任务）
12）manager 服务层，一般是定义一些公用的服务、对接第三方 API 等
13）mapper mybatis的数据库访问层，用于操作数据库
14）model 数据模型、实体类、包装类、枚举值
15）service 服务层，用于编写业务逻辑
16）utils 工具类，各种公用方法
17）wxmp 公众号相关的包
18）test 单元测试
19）MainApplication.java 项目启动入口
20）Dockerfile 用于构建 Docker 镜像



### 前后端联调

前端和后端怎么连接起来？&nbsp;&nbsp;&nbsp;&nbsp; 接口/请求 
前端发送请求调用后端接口

1）安装请求工具类 Axios 
官方文档：<https://axios-http.com/docs/intro> 
代码： `npm install axios`

2）编写调用后端的代码 
传统情况下，每个请求都要单独编写代码。至少得写一个请求路径 

使用自动生成工具：<https://github.com/ferdikoomen/openapi-typescript-codegen> 
安装：`npm install openapi-typescript-codegen --save-dev`
生成：`node node_modules/openapi-typescript-codegen/bin/index.js --input http://localhost:8121/api/v2/api-docs --output ./generated --client axios`

3）使用生成的 Service 代码，直接调用函数发送请求即可，比如获取登录信息

```ts
const res = await UserControllerService.getLoginUserUsingGet();
      if (res.code === 0) {
        commit("updateUser", res.data);
      } else {
        commit("updateUser", {
          ...state.loginUser,
          userRole: ACCESS_ENUM.NOT_LOGIN,
        });
      }
```



如果想要自定义请求参数 ：

1）使用代码生成器提供的全局参数修改对象：

```ts
export const OpenAPI: OpenAPIConfig = {
    BASE: 'http://localhost:8121',
    VERSION: '1.0',
    WITH_CREDENTIALS: false,
    CREDENTIALS: 'include',
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: undefined,
    ENCODE_PATH: undefined,
};
```

[文档](https://github.com/ferdikoomen/openapi-typescript-codegen/wiki/OpenAPI-object)

`WITH_CREDENTIALS: false`：表示客户端代码中禁用凭据传递，如果需要实现基于cookies的用户登录，需要将其改成 true。

2）直接定义 axios 请求库的全局参数，比如全局请求响应拦截器

[文档](https://axios-http.com/docs/interceptors)

示例：

```ts
// Add a request interceptor
import axios from "axios";

axios.interceptors.request.use(
  function (config) {
    // Do something before request is sent
    return config;
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error);
  }
);

// Add a response interceptor
axios.interceptors.response.use(
  function (response) {
    console.log("响应", response);
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  },
  function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  }
);

```



### 用户登录

#### 自动登录

1）在 store/user.ts 编写获取远程登录用户信息的代码

```ts
actions: {
    // 从远程请求获取登录信息
    async getLoginUser({ commit, state }, payload) {
      const res = await UserControllerService.getLoginUserUsingGet();
      if (res.code === 0) {
        commit("updateUser", res.data);
      } else {
        commit("updateUser", {
          ...state.loginUser,
          userRole: ACCESS_ENUM.NOT_LOGIN,
        });
      }
    },
  },
```

2）在一个全局的位置触发 getLoginUser  函数的执行

1. 路由拦截
2. 全局页面入口 app.vue
3. 全局通用布局（所有页面都共享的组件）



### 全局权限管理优化

1）新建 access/index.ts 文件，把原有的路由拦截、权限校验逻辑放在独立的文件中

优势：只要不引入、就不会开启、不会对项目有影响

2）编写权限管理和自动登录逻辑

如果没登录过，自动登录：

```ts
const loginUser = store.state.user.loginUser;
  // 如果之前没登录过，自动登录
  if (!loginUser || !loginUser.userRole) {
    // 加await是为了等用户登录成功之后，再执行后续的代码
    await store.dispatch("user/getLoginUser");
  }
```

如果用户访问的页面不需要登录，则不需要强制跳转到登录页

access/index.ts ：

```ts
import router from "@/router";
import store from "@/store";
import ACCESS_ENUM from "./accessEnum";
import checkAccess from "./checkAccess";

router.beforeEach(async (to, from, next) => {
  console.log("获取登录用户信息", store.state.user.loginUser);

  const loginUser = store.state.user.loginUser;
  // 如果之前没登录过，自动登录
  if (!loginUser || !loginUser.userRole) {
    // 加await是为了等用户登录成功之后，再执行后续的代码
    await store.dispatch("user/getLoginUser");
  }
  const needAccess = (to.meta?.access as string) ?? ACCESS_ENUM.NOT_LOGIN;
  // 要跳转的页面必须要登录
  if (needAccess !== ACCESS_ENUM.NOT_LOGIN) {
    // 如果没登录，跳转到登录页面
    if (!loginUser || !loginUser.userRole) {
      next(`/user/login?redirect=${to.fullPath}`);
      return;
    }
  }
  // 如果已经登录但是权限不足，那么跳转到无权限页面
  if (!checkAccess(loginUser, needAccess)) {
    next("/noAuth");
  }

  next();
});

```



### 支持多套布局

1）再 routes 路由文件中新建一套用户路由，使用 vue-router 自带的子路由机制，实现布局和嵌套自由

```ts
export const routes: Array<RouteRecordRaw> = [
  {
    path: "/user",
    name: "用户",
    component: UserLayout,
    children: [
      {
        path: "/user/login",
        name: "用户登录",
        component: UserLoginView,
      },
      {
        path: "/user/register",
        name: "用户注册",
        component: UserRegisterView,
      },
    ],
  },
```

2）新建 UserLayout、UserLoginView、UserRegisterView 页面，并且再 routes 中引入

3）在 app.vue 根页面文件，根据路由去区分多套布局

```html
<template v-if="route.path.startsWith('/user')">
	<router-view />
</template>
<template v-else>
	<BasicLayout />
</template>
```



### 登录页面开发





## 二期



### 库表设计

#### 用户表

只有管理员才能发布和管理题目，普通用户只能看题

```sql
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    unionId      varchar(256)                           null comment '微信开放平台id',
    mpOpenId     varchar(256)                           null comment '公众号openId',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin/ban',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    index idx_unionId (unionId)
) comment '用户' collate = utf8mb4_unicode_ci;
```



#### 题目表

题目标题

题目内容：存放题目的介绍、输入输出提示、描述、具体的详情

题目标签（json数组字符串）：栈、队列、链表、简单、中等、困难

题目答案：管理员/用户设置的标准答案

提交数、通过题目的人数等：便于分析统计（可以考虑根据通过率自动给题目打难易度标签）



判题相关字段：

>如果说题目不是很复杂，用例文件大小不大的话，可以直接存在数据库表里
>
>但是如果用例文件比较大，>512kb 建议单独存放在一个文件中，数据库中只保存文件 url （类似存储用户头像）



* 输入用例：1、2
* 输出用例：3、4
* 时间限制
* 内存限制



judgeConfig 判题配置（json 对象）：

* 时间限制 timeLimit

* 内存限制 memoryLimit

  

judgeCase 判题用例（json数组）：

* 每一个元素是：一个输入用例对应一个输出用例

```json
[
    {
        "input": "1 2",
        "output": "3 4"
    },
    {
        "input": "1 3",
        "output": "2 4"
    }
]
```



存 json 的好处：便于扩展，只需要改变对象内部的字段，而不用修改数据库表（可能会影响数据库）

```json
{
    "timeLimit": 1000,
    "memoryLimit": 1000,
    "stackLimit": 1000
}
```



题目表：

```sql
-- 题目表
create table if not exists question
(
    id          bigint auto_increment comment 'id' primary key,
    title       varchar(512)                       null comment '标题',
    content     text                               null comment '内容',
    tags        varchar(1024)                      null comment '标签列表（json 数组）',
    answer      text                               null comment '题目答案',
    submitNum   int      default 0                 not null comment '题目提交数',
    acceptedNum int      default 0                 not null comment '题目通过数',
    judgeCase   text                               null comment '判题用例（json 数组）',
    judgeConfig text                               null comment '判题配置（json 对象）',
    thumbNum    int      default 0                 not null comment '点赞数',
    favourNum   int      default 0                 not null comment '收藏数',
    userId      bigint                             not null comment '创建用户 id',
    createTime  datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime  datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete    tinyint  default 0                 not null comment '是否删除',
    index idx_userId (userId)
) comment '题目' collate = utf8mb4_unicode_ci;
```



#### 题目提交表

哪个用户提交了哪道题目，存放判题结果等



提交用户 id：userId

题目 id：questionId

编程语言：language

用户代码：code

判题状态：status（0 - 待判题、1 - 判题中、2 - 成功、3 - 失败）

判题信息（判题过程中得到的一些信息，比如程序失败的原因、程序执行消耗的时间空间）：judgeInfo（json 对象，单位ms、kb）

```json
{
    "message": "程序执行信息",
    "time": 1000,
    "memory": 1000, 
}
```

判题信息枚举值：

* Accepted 成功
* Wrong Answer 答案错误
* Compile Error 编译错误
* Memory Limit Exceeded 内存溢出
* Time Limit Exceeded 超时
* Presentation Error 展示错误
* Output Limit Exceeded 输出溢出
* Waiting 等待中
* Dangerous Operation 危险操作
* Runtime Error 运行错误（用户程序的问题）
* System Error 系统错误（做系统人的问题）



```sql
-- 题目提交表
create table if not exists question_submit
(
    id         bigint auto_increment comment 'id' primary key,
    language   varchar(128)                       not null comment '编程语言',
    code       text                               not null comment '用户代码',
    judgeInfo  text                               null comment '判题信息（json 对象）',
    status     int      default 0                 not null comment '判题状态（0待判题、1判题中、2成功、3失败）',
    questionId bigint                             not null comment '题目 id',
    userId     bigint                             not null comment '创建用户 id',
    createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete   tinyint  default 0                 not null comment '是否删除',
    index idx_postId (questionId),
    index idx_userId (userId)
) comment '题目提交表';
```



tips：

什么情况下要加索引？如何选择给哪个字段加索引？

首先从业务出发，无论是单个索引还是联合索引，都要从你实际的查询语句、字段枚举值的区分度、字段的类型考虑（where 条件指定的字段）

比如：where userId = 1 and questionId = 2

可以选择根据 userId 和 questionId 分别建立索引（需要分别根据这两个字段单独查询）；也可以选择给这两个字段建立联合索引（所查询的字段是绑定在一起的）

原则上：能不用索引就不用；能用单个索引就别用联合/多个索引；不要给没区分度的字段加索引（比如性别）。因为索引也是要占用空间的



### 后端接口开发

#### 后端开发流程

1）根据功能设计库表

2）自动生成对数据库基本的增删改查（mapper 和 service 层的基本功能）

3）编写 Controller 层，实现基本的增删改查和权限校验（复制粘贴）

4）根据业务定制开发新的功能，编写新的代码



更好的方法：编写自己的代码生成器



#### 代码生成方法

1）安装 MybatisX 插件

2）根据项目去调整生成配置，建议生成代码到独立的包，不要影响老的项目

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240806143917769.png" alt="image-20240806143917769" style="zoom: 50%;" />

3）把代码从生成包中移到实际项目对应目录中

4）找相似的代码去复制 Controller

* 单表去复制单表 Controller（比如 question => post）
* 关联表去复制关联表（比如 question_submit => post_thumb)

5）复制实体类相关的 DTO、VO、枚举值字段（用于接收前端请求、业务间传递），复制之后调整对应的字段

updateRequest 和 editRequest 的区别：前者是给管理员更新用的，可以指定更多字段；后者是给普通用户使用的，只能指定部分字段

6）为了更方便地处理 json 字段中的某个字段，需要给对应的 json 字段编写独立的类，比如 judgeConfig、judgeInfo、judgeCase

```java
/**
 * 题目用例
 */
@Data
public class JudgeCase {

    /**
     * 输入用例
     */
    private String input;

    /**
     * 输出用例
     */
    private String output;
}
```



tips：

什么情况下要加业务前缀？什么情况布局？

加业务前缀的好处，防止多个表都有类似的类，产生冲突；不加的前提，因为可能这个类是多个业务之间共享的，能够保证唯一



定义 VO 类：作用是专门给前端返回对象，可以节约网络传输大小、或者过滤字段（脱敏）、保证安全性。比如 judgeCase、answer字段一定要删，不能直接给用户答案



7）校验 Controller 层的代码，看看除了要调用的方法缺失外，还有无报错

8）实现 Service 层的代码，从对应的已经编写好的实现类复制粘贴，全局替换（比如 question => post）

9）编写 QuestionVO 的 json/对象 转换工具类

10）用同样的方法，编写 questionSubmit 提交类，这次参考 postThumb 相关代码

11）编写枚举类

```java
public enum QuestionSubmitLanguageEnum {

    JAVA("java", "java"),
    CPLUSPLUS("c++", "c++"),
    GOLANG("golang", "golang");

    private final String text;

    private final String value;

    QuestionSubmitLanguageEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 获取值列表
     *
     * @return
     */
    public static List<String> getValues() {
        return Arrays.stream(values()).map(item -> item.value).collect(Collectors.toList());
    }

    /**
     * 根据 value 获取枚举
     *
     * @param value
     * @return
     */
    public static QuestionSubmitLanguageEnum getEnumByValue(String value) {
        if (ObjectUtils.isEmpty(value)) {
            return null;
        }
        for (QuestionSubmitLanguageEnum anEnum : QuestionSubmitLanguageEnum.values()) {
            if (anEnum.value.equals(value)) {
                return anEnum;
            }
        }
        return null;
    }

    public String getValue() {
        return value;
    }

    public String getText() {
        return text;
    }
}
```

编写好基本代码后，记得通过 Swagger 或者编写单元测试去验证。



tips:

为了防止用户按照 id 顺序爬取题目，建议把 id 的生成规则改为 ASSIGN_ID 而不是从 1 开始自增

```java
	/**
     * id
     */
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
```



#### 查询提交信息

功能：能够根据用户 id 、题目 id、编程语言，去查询提交记录

注意事项：仅本人和管理员能看见自己（提交 userId 和登录 userId 不同）提交的代码



实现方案：先查询，再根据权限去脱敏

```java
@Override
public QuestionSubmitVO getQuestionSubmitVO(QuestionSubmit questionSubmit, User loginUser) {
    QuestionSubmitVO questionSubmitVO = QuestionSubmitVO.objToVo(questionSubmit);
    // 脱敏：仅本人和管理员能看见自己（提交 userId 和登录 userId 不同）提交的代码
    long userId = loginUser.getId();
    if (userId != questionSubmit.getUserId() && !userService.isAdmin(loginUser)){
        questionSubmitVO.setCode(null);
    }
    return questionSubmitVO;
}
```









## 三期



### 计划

前端开发为主：

1）用户注册页面

2）创建题目页面（管理员）

3）题目管理页面（管理员）

* 查看
* 删除
* 修改
* 快捷创建

4）题目列表页（用户）

5）题目详情页

* 判题状态查看

6）题目提交列表页



> 扩展：提交统计页、用户个人页



### 接入要用到的组件

先接入可能要用的组件，再去写页面，避免因为后续依赖冲突、整合组件失败带来的返工



#### Markdown 编辑器

一套通用的文本编辑语法，可以在各大网站上同意标准、渲染出统一的样式，比较简单一些



[开源编辑器 bytemd](https://github.com/bytedance/bytemd)

阅读官方文档，下载编辑器主体、gfm（表格支持）插件、highlight（代码高亮）插件

```shell
npm install @bytemd/vue-next
npm install @bytemd/plugin-gfm
npm install @bytemd/plugin-highlight
```

新建 MdEdior 组件，编写代码：

```vue
<template>
  <Editor :value="value" :plugins="plugins" @change="handleChange" />
</template>

<script setup lang="ts">
import gfm from "@bytemd/plugin-gfm";
import highlight from "@bytemd/plugin-highlight";
import { Editor, Viewer } from "@bytemd/vue-next";
import { ref } from "vue";

const plugins = [
  gfm(),
  highlight(),
  // Add more plugins here
];

const value = ref("");
const handleChange = (v: string) => {
  value.value = v;
};
</script>
```



隐藏编辑器中不需要的操作图标：

```css
.bytemd-toolbar-icon.bytemd-tippy.bytemd-tippy-right:last-child {
    display: none;
}
```



要把 MdEditor 当前输入的值暴露给父组件，便于父组件去使用，同时也是提高组件的通用性，需要定义属性，把 value 和 handleChange 事件交给父组件去管理

MdEditor.vue：

```ts
/**
 * 定义组件属性类型
 */
interface Props {
  value: string;
  handleChange: (v: string) => void;
}

/**
 * 给组件指定初始值
 */
const props = withDefaults(defineProps<Props>(), {
  value: () => "",
  handleChange: (v: string) => {
    console.log(v);
  },
});
```



#### 代码编辑器

微软官方编辑器：[microsoft/monaco-editor](https://github.com/microsoft/monaco-editor)

官方教程：[monaco-editor/docs/integrate-esm.md](https://github.com/microsoft/monaco-editor/blob/main/docs/integrate-esm.md)

1）安装编辑器

```shell
npm install monaco-editor
```

2）vue-cli 项目（webpack项目）整合 monaco-editor

先安装[monaco-editor-webpack-plugin](https://github.com/microsoft/monaco-editor/tree/main/webpack-plugin)

```shell
npm install monaco-editor-webpack-plugin
```

在 vue.config.js 中配置 webpack 插件：

全量加载：

```ts
const { defineConfig } = require("@vue/cli-service");
const MonacoWebpackPlugin = require("monaco-editor-webpack-plugin");

module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave: false, //关闭eslint校验
  chainWebpack(config) {
    config.plugin("monaco").use(new MonacoWebpackPlugin());
  },
});
```

按需加载：

```ts
module.exports = defineConfig({
  chainWebpack: (config) => {
    config.plugin("monaco-editor").use(MonacoWebpackPlugin, [
      {
        // Languages are loaded on demand at runtime
        languages: ['json', 'go', 'css', 'html', 'java', 'javascript', 'less', 'markdown', 'mysql', 'php', 'python', 'scss', 'shell', 'redis', 'sql', 'typescript', 'xml'], // ['abap', 'apex', 'azcli', 'bat', 'cameligo', 'clojure', 'coffee', 'cpp', 'csharp', 'csp', 'css', 'dart', 'dockerfile', 'ecl', 'fsharp', 'go', 'graphql', 'handlebars', 'hcl', 'html', 'ini', 'java', 'javascript', 'json', 'julia', 'kotlin', 'less', 'lexon', 'lua', 'm3', 'markdown', 'mips', 'msdax', 'mysql', 'objective-c', 'pascal', 'pascaligo', 'perl', 'pgsql', 'php', 'postiats', 'powerquery', 'powershell', 'pug', 'python', 'r', 'razor', 'redis', 'redshift', 'restructuredtext', 'ruby', 'rust', 'sb', 'scala', 'scheme', 'scss', 'shell', 'solidity', 'sophia', 'sql', 'st', 'swift', 'systemverilog', 'tcl', 'twig', 'typescript', 'vb', 'xml', 'yaml'],

        features: ['format', 'find', 'contextmenu', 'gotoError', 'gotoLine', 'gotoSymbol', 'hover' , 'documentSymbols'] //['accessibilityHelp', 'anchorSelect', 'bracketMatching', 'caretOperations', 'clipboard', 'codeAction', 'codelens', 'colorPicker', 'comment', 'contextmenu', 'coreCommands', 'cursorUndo', 'dnd', 'documentSymbols', 'find', 'folding', 'fontZoom', 'format', 'gotoError', 'gotoLine', 'gotoSymbol', 'hover', 'iPadShowKeyboard', 'inPlaceReplace', 'indentation', 'inlineHints', 'inspectTokens', 'linesOperations', 'linkedEditing', 'links', 'multicursor', 'parameterHints', 'quickCommand', 'quickHelp', 'quickOutline', 'referenceSearch', 'rename', 'smartSelect', 'snippets', 'suggest', 'toggleHighContrast', 'toggleTabFocusMode', 'transpose', 'unusualLineTerminators', 'viewportSemanticTokens', 'wordHighlighter', 'wordOperations', 'wordPartOperations']
      }
    ]);
  },
});
```



官方示例教程：[Monaco Editor](https://microsoft.github.io/monaco-editor/playground.html?source=v0.50.0#example-creating-the-editor-hello-world)

技术博客参考：[vsCode 之 Monaco Editor 在 vue-cli3.0 中的使用方法](http://zhenglinglu.cn/pages/e488ab/)

注意， monaco editor 在读写值的时候，要使用 toRaw（编辑器实例）的语法来执行操作，否则会卡死

CodeEditor.vue：

```vue
<template>
  <div id="code-editor" ref="codeEditorRef" style="min-height: 400px" />
  {{ value }}
  <a-button @click="fillValue">填充值</a-button>
</template>

<script setup lang="ts">
import * as monaco from "monaco-editor";
import { onMounted, ref, toRaw } from "vue";

const codeEditorRef = ref();
const codeEditor = ref();
const value = ref("hello world");

const fillValue = () => {
  if (!codeEditor.value) {
    return;
  }
  toRaw(codeEditor.value).setValue("新的值");
};

onMounted(() => {
  if (!codeEditorRef.value) {
    return;
  }
  // Hover on each property to see its docs!
  codeEditor.value = monaco.editor.create(codeEditorRef.value, {
    value: value.value,
    language: "java",
    automaticLayout: true,
    colorDecorators: true,
    minimap: {
      enabled: true,
    },
    readOnly: false,
    theme: "vs",
    // lineNumbers: "off",
    // roundedSelection: false,
    // scrollBeyondLastLine: false,
  });

  // 编辑 监听内容变化
  codeEditor.value.onDidChangeModelContent(() => {
    console.log("目前内容为：", toRaw(codeEditor.value).getValue());
  });
});
</script>
```

同 Md 编辑器一样，也要接收父组件的传值、把显示的输入交给父组件去控制，让父组件实时得到用户输入的代码：

```ts
/**
 * 定义组件属性类型
 */
interface Props {
  value: string;
  handleChange: (v: string) => void;
}

/**
 * 给组件指定初始值
 */
const props = withDefaults(defineProps<Props>(), {
  value: () => "",
  handleChange: (v: string) => {
    console.log(v);
  },
});
```



> 项目扩展：用 diff editor 对比用户代码和标准答案的区别





### 页面开发



#### 创建题目页面

重新根据后端生成前端请求代码：

```shell
node node_modules/openapi-typescript-codegen/bin/index.js --input http://localhost:8121/api/v2/api-docs --output ./generated --client axios
```

重新生成后要记得修改 OpenAPI.ts中的 WITH_CREDENTIALS 为 true 防止无法登录



需要用户输入的值

```js
{
  "answer": "答案",
  "content": "内容",
  "judgeCase": [
    {
      "input": "1 2",
      "output": "3 4"
    }
  ],
  "judgeConfig": {
    "memoryLimit": 1000,
    "stackLimit": 1000,
    "timeLimit": 1000
  },
  "tags": ["栈"],
  "title": "A"
}
```



tips:

vscode 中自定义代码模板：文件=>首选项=>配置代码片段=>新建全局代码片段文件

```ts
{
	// Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "vue,javascript,typescript",
		"prefix": "myvuepage",
		"body": [
			"<template>",
			"\t<div id=\"$1${TM_FILENAME_BASE}\"></div>",
			"</template>",
			"",
			"<script setup lang=\"ts\">",
			"$2",
			"</script>",
			"",
			"<style scoped>",
			"#$1${TM_FILENAME_BASE} {",
			"",
			"}",
			"</style>",
		],
		"description": "我的vue模板页面"
	}
}
```

在需要使用的地方输入设置的 prefix 即 myvuepage 即可生成 body 中的模板代码



使用表单组件，先复制示例代码，再修改：[ArcoDesign Form表单](https://arco.design/vue/component/form)

此处我们用到了嵌套表单和动态增减表单：[ArcoDesign 嵌套数据](https://arco.design/vue/component/form#nest)	[ArcoDesign 动态表单](https://arco.design/vue/component/form#dynamic)



注意，我们自定义的代码编辑器不会被组件库识别，需要手动指定 value 和 handleChange 函数





#### 题目管理页面

1）使用表格组件：[ArcoDesign Table](https://arco.design/vue/component/table#custom)（需要找到自定义操作的示例）

2）查询数据

3）定义表格列

4）加载数据

5）调整格式

比如 json 格式不好看，有两种方法调整：

1. 使用组件库自带的语法，自动格式化
2. 完全自定义渲染，想展示什么就展示什么

6）添加删除、更新操作

删除后更新：执行 loadData 刷新





#### 更新页面开发

策略：由于更新和创建都是相同的表单，完全没必要开发/复制两遍，可以直接复用页面

区分两个页面：

1. 路由（/add/question 和 /update/question）
2. 请求参数（ id=1 ）



更新页面相较于创建页面：

1）在加载页面时，更新页面要加载之前的数据

2）在提交时，请求的地址不同







## 四期

### 计划

1. 前端页面开发（题目浏览页、题目列表搜索页）
2. 后端判题模块的预开发（ 2 - 4 种设计模式），跑通整个项目的前后端流程



### 前端页面开发

#### 现有代码优化

1）先处理菜单项的权限控制和显示隐藏

如更新题目：

```ts
{
    path: "/update/question",
    name: "更新题目",
    component: AddQuestionView,
    meta: {
      access: [ACCESS_ENUM.USER, ACCESS_ENUM.ADMIN],
      hideInMenu: true,
    },
  },
```



2）管理页面分页问题的修复

在分页页号改变时，触发事件 @page-change ，改变 searchParams 的值，并且通过 watchEffect 监听 searchParams 的改变，实现了页号变化时触发数据的重新加载



3）修复刷新页面未登录的问题

src/access/index.ts：

```ts
if (!loginUser || !loginUser.userRole) {
    // 加await是为了等用户登录成功之后，再执行后续的代码
    await store.dispatch("user/getLoginUser");
    loginUser = store.state.user.loginUser;
  }
```



#### 题目列表搜索页

表格组件：[ArcoDesign Table](https://arco.design/vue/component/table#custom)

1）复制管理题目页的表格

2）保留需要的 columns 字段

3）自定义表格列的渲染

标签：使用 Tags 组件

通过率：自行计算

创建时间：使用 moment 库进行格式化：[Moment.js | Docs](https://momentjs.com/docs/#/displaying/)

操作按钮：补充跳转到做题页面 toQuestionPage

4）编写搜索表单，使用 form 的 layout = inline 布局，让用户的输入和 searchParams 同步，并且给搜索按钮绑定修改 searchParams，被 watchEffect 监听到，触发查询



#### 题目浏览页

1）先定义动态参数路由，开启 props 为 true ，可以在页面的 props 中直接获取到动态参数（题目 id）

```ts
{
    path: "/view/question/:id",
    name: "在线做题",
    component: ViewQuestionView,
    props: true,
    meta: {
      access: [ACCESS_ENUM.USER, ACCESS_ENUM.ADMIN],
      hideInMenu: true,
    },
  },
```



2）定义布局：左侧是题目信息，右侧是代码编辑器

题目信息：

* tabs 切换展示的内容
* 定义 MdViewer 组件展示题目内容
* 使用 descriptions 组件展示判题配置 [ArcoDesign Descriptions](https://arco.design/vue/component/descriptions)

代码编辑器：

* 使用 select 组件让用户选择编程语言
* 在代码编辑器中监听属性的变化，注意监听 props 要使用箭头函数[vue3使用watch监听props两大坑](https://www.jianshu.com/p/3570b7df3d1f)

> todo：代码编辑器没有更改语言





### 判题机模块预开发

目的：跑通完整的业务流程



#### 梳理判题模块和代码沙箱的关系

判题模块：调用代码沙箱，把代码和输入交给代码沙箱去执行

代码沙箱：只负责接收代码和输入，返回编译运行的结果，不负责判题

这两个模块完全解耦

![image-20240829193549686](C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240829193549686.png)

> 为什么代码沙箱要接收和输出一组运行用例？
>
> 前提：我们的每道题目有多组测试用例
>
> 如果是每个用例单独调用一次代码沙箱，会调用多次接口、需要多次网络传输、程序要多次编译、记录程序的执行状态（重复的代码不重复编译）
>
> 这是一种很常见的性能优化方法！批处理



#### 代码沙箱开发

1）定义代码沙箱的接口，提高通用性，之后我们的项目代码只调用接口，不调用具体的实现类，使用其他的代码沙箱实现类时，就不用去修改名称，便于扩展。

> 代码沙箱的请求接口中，timeLimit 可加或不加，可自行扩展，即时中断程序

扩展思路：增加一个查看代码沙箱状态的接口



2）定义多种不同的代码沙箱实现：

* 示例代码沙箱：仅为了跑通业务流程

* 远程代码沙箱：实际调用接口的沙箱

* 第三方代码沙箱：调用网上现成的代码沙箱 [criyle/go-judge: Sandbox Server in REST / gRPC API](https://github.com/criyle/go-judge)



3）编写单元测试，验证单个代码沙箱的执行

```java
@SpringBootTest
class CodeSandboxTest {

    @Test
    void executeCode() {
        CodeSandbox codeSandbox = new ExampleCodeSandbox();
        String code = "int main() { }";
        String language = QuestionSubmitLanguageEnum.JAVA.getValue();
        List<String> inputList = Arrays.asList("1 2","3 4");
        ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()
                .code(code)
                .language(language)
                .inputList(inputList)
                .build();
        ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);
        Assertions.assertNotNull(executeCodeResponse);
    }
}
```



现在的问题在于 new 某个沙箱的代码是写死的，如果项目要改用其他沙箱，可能需要修改很多的代码



4）使用工厂模式，根据用户传入的字符串参数，来生成对应的代码沙箱实现类

此处使用静态工厂模式，实现比较简单，符合需求

```java
/**
 * 代码沙箱创建工厂（根据字符串参数创建指定的代码沙箱实例）
 */
public class CodeSandboxFactory {

    /**
     * 创建代码沙箱实例
     *
     * @param type 沙箱类型
     * @return
     */
    public static CodeSandbox newInstance(String type) {
        switch (type) {
            case "example":
                return new ExampleCodeSandbox();
            case "remote":
                return new RemoteCodeSandbox();
            case "thirdParty":
                return new ThirdPartyCodeSandbox();
            default:
                return new ExampleCodeSandbox();
        }
    }
}
```

> 扩展思路：如果确定代码沙箱实例不会出现线程安全问题、可复用，那么可以使用单例工厂模式

由此，我们可以根据字符串动态生成实例，提高了通用性：

```java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String type = scanner.next();
            CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);
            String code = "int main() { }";
            String language = QuestionSubmitLanguageEnum.JAVA.getValue();
            List<String> inputList = Arrays.asList("1 2","3 4");
            ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()
                    .code(code)
                    .language(language)
                    .inputList(inputList)
                    .build();
            ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);
        }
    }
```



5）参数配置化，把项目中的一些可交给用户去自定义的选项或字符串，写到配置文件中。这样开发者只需要改配置文件，而不需要去看你的项目代码就能够自定义使用你项目的更多功能。

application.yml 配置文件中指定变量：

```yml
# 代码沙箱配置
codesandbox:
  type: remote
```

在 Spring 的 Bean 中通过 @Value 注解读取：

```java
@Value("${codesandbox.type:example}")
private String type;
```



6）代码沙箱能力增强

比如：我们需要在调用代码沙箱前，输出请求参数日志；在代码沙箱调用后，输出响应结果日志，便于管理员去分析。

可使用代理模式，提供一个 Proxy，来增强代码沙箱的能力（代理模式的作用就是增强能力）

原本：需要用户调用多次

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240830223928452.png" alt="image-20240830223928452" style="zoom: 80%;" />

使用代理后：不仅不用改变原本的代码沙箱实现类，而且对调用者来说，调用方式几乎没有改变，也不需要在每个调用沙箱的地方去写统计代码

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240830223954182.png" alt="image-20240830223954182" style="zoom:80%;" />

使用方式：

```java
CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);
codeSandbox = new CodeSandboxProxy(codeSandbox);
```



7）实现示例的代码沙箱

```java
/**
 * 示例代码沙箱（仅为了跑通业务流程）
 */
public class ExampleCodeSandbox implements CodeSandbox {
    @Override
    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) {
        List<String> inputList = executeCodeRequest.getInputList();
        ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();
        executeCodeResponse.setOutputList(inputList);
        executeCodeResponse.setMessage("测试执行成功");
        executeCodeResponse.setStatus(QuestionSubmitStatusEnum.SUCCEED.getValue());
        JudgeInfo judgeInfo = new JudgeInfo();
        judgeInfo.setMessage(JudgeInfoMessageEnum.ACCEPTED.getText());
        judgeInfo.setMemory(100L);
        judgeInfo.setTime(100L);
        executeCodeResponse.setJudgeInfo(judgeInfo);
        return executeCodeResponse;
    }
}
```



**tips**：Lombok Builder 注解

实体类加上：

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExecuteCodeRequest {
    private List<String> inputList;

    private String code;

    private String language;
}
```

可以使用链式的方式更方便地给对象赋值：

```java
ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()
                .code(code)
                .language(language)
                .inputList(inputList)
                .build();
```



### 判题服务完整业务流程实现

判题服务业务流程： 

1）传入题目的提交 id，获取到对应的题目、提交信息（包含代码、编程语言等）

2）如果题目提交状态不为等待中，就不用重复执行

3）更改判题（题目提交）的状态为” 判题中 “，防止重复执行，也能让用户即时看到状态

4）调用沙箱，获取到执行结果

5）根据沙箱的执行结果，设置题目状态和信息



判断逻辑：

1. 先判断沙箱执行的结果输出数量是否和预期输出数量相等
2. 依次判断每一项输出和预期输出是否相等
3. 判断题目的限制是否符合要求
4. 可能还有其他的异常输出



#### 策略模式优化判题代码

我们的判题策略可能会有很多种，比如：我们的代码沙箱本身执行程序需要消耗时间，这个时间可能不同的编程语言是不同的，比如沙箱执行 Java 要额外花 10 秒

我们可以采用策略模式，针对不同的情况，定义独立的策略，而不是把所有的判题逻辑、if...else 代码全部混在一起写



首先编写默认判题模块

如果选择某种判题策略的过程比较复杂，都写在调用判题服务的代码中，代码会越来越复杂，会有很多 if...else，所以建议单独写一个判断策略的类

```java
JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();
        if(language.equals("java")){
            judgeStrategy = new JavaLanguageJudgeStrategy();
        }
        JudgeInfo judgeInfo = judgeStrategy.dojudge(judgeContext);
```

定义 JudgeManager，目的是尽量简化对判题功能的调用，让调用方最简单

```java
/**
 * 判题管理（简化调用）
 */
@Service
public class JudgeManager {

    /**
     * 执行判题
     * @param judgeContext
     * @return
     */
    JudgeInfo dojudge(JudgeContext judgeContext){
        QuestionSubmit questionSubmit = judgeContext.getQuestionSubmit();
        String language = questionSubmit.getLanguage();

        JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();
        if("java".equals(language)){
            judgeStrategy = new JavaLanguageJudgeStrategy();
        }
        return judgeStrategy.dojudge(judgeContext);
    }
}
```





## 五期

### 计划

1. 历史问题修复
2. Java 原生实现代码沙箱
3. Docker 实现代码沙箱



### 历史问题修复

代码编辑器切换语言失败问题

解决：监听 language 属性，动态更改编辑器的语言

```ts
watch(() => props.language, () => {
  if (codeEditor.value) {
    monaco.editor.setModelLanguage(toRaw(codeEditor.value).getModel(), props.language)
  }
})
```



### 代码沙箱实现

代码沙箱：只负责接收代码和输入，返回编译运行的结果，不负责判题（可作为独立的项目/服务，提供给其他的需要执行代码的项目去使用）

以 Java 编程语言为主，实现代码沙箱，重要的是学思想、学关键流程

> 扩展：可以自行实现 C++ 语言的代码沙箱



新建一个 Spring Boot Web 项目，最终这个项目要提供一个能够执行代码、操作代码沙箱的接口

选择 java 8，springboot 2.7

编写启动配置：

```yaml
server:
  port: 8090
```

编写测试接口，验证能否访问：

```java
package com.dan.danojcodesandbox.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController("/")
public class MainController {

    @GetMapping("/health")
    public String healthCheck() {
        return "OK";
    }
}
```



#### Java 原生实现代码沙箱

原生：尽可能不借助第三方库和依赖，用最干净、最原始的方式实现代码沙箱

代码沙箱需要：接收代码 => 编译代码（javac） => 执行代码（java）



编写示例代码，注意要去包名，放到 resources 目录下：

```java
public class SimpleCompute {
    public static void main(String[] args) {
        int a = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        System.out.println("结果:" + (a + b));
    }
}
```



编译代码：

```shell
javac .\SimpleCompute.java
```

编译后的程序中文乱码：

命令行终端的编码是 GBK，和 java 代码文件本身的编码 UTF-8 不一致，导致乱码

在 javac 后加 -encoding utf-8 ：

```shell
javac -encoding utf-8 .\SimpleCompute.java
```

执行：

```shell
java -cp C:\project\OJ_System\oj-code-sandbox\src\main\resources\testCode\simpleComputeArgs SimpleCompute 1 2  
```



实际 OJ 系统中，对用户输入的代码会有一定的要求，便于系统统一地处理。所以此处，我们把用户输入代码的类名限制为 Main（参考Poj），减少类名不一致的风险，而且不用从用户代码中提取类名，更方便

示例 Main.java：

```java
public class Main {
    public static void main(String[] args) {
        int a = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        System.out.println("结果:" + (a + b));
    }
}
```

实际执行：

```shell
javac -encoding utf-8 .\Main.java
java -cp . Main 1 2
```



#### 核心流程实现

核心实现思路：用程序代替人工，用程序来操作命令行，去编译执行代码

Java 进程执行管理类：Process

1. 把用户的代码保存为文件
2. 编译代码，得到 class 文件
3. 执行代码，得到输出结果
4. 收集整理输出结果
5. 文件清理
6. 错误处理，提升程序健壮性



##### 1）把用户的代码保存为文件

引入 Hutool 工具类：

```xml
<!-- https://hutool.cn/docs/index.html#/-->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.8</version>
</dependency>
```

新建目录，每个用户的代码都存放在独立目录下，便于维护：

```java
List<String> inputList = executeCodeRequest.getInputList();
String code = executeCodeRequest.getCode();
String language = executeCodeRequest.getLanguage();

String userDir = System.getProperty("user.dir");
String globalCodePathName = userDir + File.separator + GLOBAL_CODE_DIR_NAME;
// 判断全局代码目录是否存在，没有则新建
if(!FileUtil.exist(globalCodePathName)){
    FileUtil.mkdir(globalCodePathName);
}

// 把用户的代码隔离存放
String userCodeParentPath = globalCodePathName + File.separator + UUID.randomUUID();
String userCodePath = userCodeParentPath+File.separator + GLOBAL_JAVA_CLASS_NAME;
File userCodeFile = FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);
```



##### 2）编译代码，得到 class 文件

Java 执行程序：

```java
String compileCmd = String.format("javac -encoding utf-8 %s", userCodeFile.getAbsolutePath());
Process compileProcess = Runtime.getRuntime().exec(compileCmd);
```

Java 获取控制台的输出，通过 exitValue 判断程序是否正常返回，从 inputStream 和 errorStream 获取控制台输出：

```java
int exitValue = compileProcess.waitFor();
// 正常退出
if (exitValue == 0) {
    System.out.println("编译成功");
    // 分批获取进程的输出
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));
    StrBuilder compileOutputStringBuilder = new StrBuilder();
    // 逐行读取
    String compileOutputLine;
    while ((compileOutputLine = bufferedReader.readLine()) != null) {
        compileOutputStringBuilder.append(compileOutputLine);
    }
    System.out.println(compileOutputStringBuilder);
} else {
    // 异常退出
    System.out.println("编译失败，错误码：" + exitValue);
    // 分批获取进程的正常输出
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));
    StrBuilder compileOutputStringBuilder = new StrBuilder();
    // 逐行读取
    String compileOutputLine;
    while ((compileOutputLine = bufferedReader.readLine()) != null) {
        compileOutputStringBuilder.append(compileOutputLine);
    }

    // 分批获取进程的错误输出
    BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getErrorStream()));
    StrBuilder errorCompileOutputStringBuilder = new StrBuilder();
    // 逐行读取
    String errorCompileOutputLine;
    while ((errorCompileOutputLine = errorBufferedReader.readLine()) != null) {
        errorCompileOutputStringBuilder.append(errorCompileOutputLine);
    }
    System.out.println(compileOutputStringBuilder);
}

```

编写一个工具类，执行进程，并且获取输出

```java
package com.dantalian.ojcodesandbox.utils;

import cn.hutool.core.text.StrBuilder;
import com.dantalian.ojcodesandbox.model.ExecuteMessage;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * 进程工具类
 */
public class ProcessUtils {

    /**
     * 执行进程并获取信息
     * @param process
     * @return
     */
    public static ExecuteMessage runProcessAndGetMessage(Process process, String opName) {
        ExecuteMessage executeMessage = new ExecuteMessage();
        try {
            // 等待程序执行，获取错误码
            int exitValue = process.waitFor();
            executeMessage.setExitValue(exitValue);
            
            // 正常退出
            if (exitValue == 0) {
                System.out.println(opName + "成功");
                // 分批获取进程的输出
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StrBuilder compileOutputStringBuilder = new StrBuilder();
                // 逐行读取
                String compileOutputLine;
                while ((compileOutputLine = bufferedReader.readLine()) != null) {
                    compileOutputStringBuilder.append(compileOutputLine);
                }
                executeMessage.setMessage(compileOutputStringBuilder.toString());
                System.out.println(compileOutputStringBuilder);
            } else {
                // 异常退出
                System.out.println(opName + "失败，错误码：" + exitValue);
                // 分批获取进程的正常输出
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StrBuilder compileOutputStringBuilder = new StrBuilder();
                // 逐行读取
                String compileOutputLine;
                while ((compileOutputLine = bufferedReader.readLine()) != null) {
                    compileOutputStringBuilder.append(compileOutputLine);
                }

                // 分批获取进程的错误输出
                BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                StrBuilder errorCompileOutputStringBuilder = new StrBuilder();
                // 逐行读取
                String errorCompileOutputLine;
                while ((errorCompileOutputLine = errorBufferedReader.readLine()) != null) {
                    errorCompileOutputStringBuilder.append(errorCompileOutputLine);
                }
                executeMessage.setErrorMessage(compileOutputStringBuilder.toString());
                System.out.println(compileOutputStringBuilder);
            }
        } catch (Exception e){
            e.printStackTrace();
        }
        return executeMessage;
    }
}


```



##### 3）执行代码，得到输出结果

出现乱码，加 -Dfile.encoding=UTF-8：

```shell
java -Dfile.encoding=UTF-8 -cp %s Main %s
```

很多 OJ 都是 ACM 模式，需要和用户交互的方式，让用户不断地输入内容并获取输出，比如：

```java
import java.io.*;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner cin = new Scanner(System.in);
        int a = cin.nextInt(), b = cin.nextInt();
        System.out.println(a + b);
    }
}
```

对于此类程序，我们需要使用OutputStream 向程序终端发送，并及时获取结果，注意最后要关闭流释放资源：

```java
/**
* 执行交互式进程并获取信息
* @param process
* @return
*/
public static ExecuteMessage runInteractProcessAndGetMessage(Process process, String args) {
    ExecuteMessage executeMessage = new ExecuteMessage();
    try {
        // 向控制台输入程序
        OutputStream outputStream = process.getOutputStream();
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
        String[] s = args.split(" ");
        outputStreamWriter.write(StrUtil.join("\n",s) + "\n");
        // 相当于按回车
        outputStreamWriter.flush();

        // 分批获取进程的输出
        InputStream inputStream = process.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        StrBuilder compileOutputStringBuilder = new StrBuilder();
        // 逐行读取
        String compileOutputLine;
        while ((compileOutputLine = bufferedReader.readLine()) != null) {
            compileOutputStringBuilder.append(compileOutputLine);
        }
        executeMessage.setMessage(compileOutputStringBuilder.toString());
        // 回收资源
        outputStreamWriter.close();
        outputStream.close();
        inputStream.close();
        process.destroy();
    } catch (Exception e){
        e.printStackTrace();
    }
    return executeMessage;
}
```



##### 4）整理输出

获取程序执行时间，使用 spring 的 StopWatch 获取一段程序的执行时间：

```java
StopWatch stopWatch = new StopWatch();
stopWatch.start();
// 此处是一段程序
stopWatch.stop();
long lastTaskTimeMillis = stopWatch.getLastTaskTimeMillis();
executeMessage.setTime(lastTaskTimeMillis);
```

此处我们使用最大值来统计时间：

```java
// 取用时最大值，便于判断是否超时
long maxTime = 0;
for (ExecuteMessage executeMessage : executeMessageList) {
    // ···
    Long time = executeMessage.getTime();
    if (time != null) {
        maxTime = Math.max(maxTime, time);
    }
}
```



##### 5）文件清理

防止服务器空间不足：

```java
// 5. 文件清理
if (userCodeFile.getParentFile() != null) {
    boolean del = FileUtil.del(userCodeParentPath);
    System.out.println("删除" + (del ? "成功" : "失败"));
}
```



##### 6）错误处理

封装一个错误处理方法，当程序抛出异常时，直接返回错误响应：

```java
/**
* 获取错误响应
* @param e
* @return
*/
private ExecuteCodeResponse getErrorResponse(Throwable e) {
    ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();
    executeCodeResponse.setMessage(e.getMessage());
    // 表示代码沙箱错误
    executeCodeResponse.setStatus(2);
    executeCodeResponse.setJudgeInfo(new JudgeInfo());
    return executeCodeResponse;
}
```



#### 异常情况演示



到目前为止，核心流程已经实现，但是想要上线的话，并不安全

用户提交恶意代码怎么办



##### 1）执行阻塞，占用资源不释放

时间上

```java
/**
 * 无限睡眠（阻塞程序执行）
 */
public class SleepError {
    public static void main(String[] args) throws InterruptedException {
        long ONE_HOUR = 60 * 60 * 1000;
        Thread.sleep(ONE_HOUR);
        System.out.println("睡完了");
    }
}
```

要把写好的代码复制到 resources 中，并且要把类名改为 Main，把包名去掉



##### 2）占用内存，不释放

空间上

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 无限占用空间（浪费系统内存）
 */
public class Main {
    public static void main(String[] args) throws InterruptedException {
        List<byte[]> bytes = new ArrayList<>();
        while (true) {
            bytes.add(new byte[10000]);
        }
    }
}
```

实际运行中，我们会发现，内存占用到达一定空间后，程序就会自动报错：java.lang.OutOfMemoryError: Java heap space

这是 JVM 的一个保护机制

> JVisualIVM 或 JConsole 工具，可以连接到 JVM 虚拟机上来可视化查看运行状态

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240910155612425.png" alt="image-20240910155612425" style="zoom:50%;" />



##### 3）读文件，文件信息泄露

直接通过相对路径获取文件

```java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

/**
 * 读取服务器文件（文件信息泄露）
 */
public class Main {
    public static void main(String[] args) throws InterruptedException, IOException {
        String userDir = System.getProperty("user.dir");
        String filePath = userDir + File.separator + "src/main/resources/application.yml";
        List<String> allLines = Files.readAllLines(Paths.get(filePath));
        System.out.println(String.join("\n", allLines));
    }
}
```



##### 4）写文件，越权植入木马

假设有一个木马程序：java -version 2>&1

```java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;


/**
 * 向服务器写文件（植入危险程序）
 */
public class Main {
    public static void main(String[] args) throws InterruptedException, IOException {
        String userDir = System.getProperty("user.dir");
        String filePath = userDir + File.separator + "src/main/resources/木马程序.bat";
        String errorProgram = "java -version 2>&1";
        Files.write(Paths.get(filePath), Arrays.asList(errorProgram));
        System.out.println("写木马成功，你完了哈哈");
    }
}
```



##### 5）运行其他程序

直接通过 Process 执行危险程序，或者电脑上的其他程序：

```java
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 运行其他程序（比如危险木马）
 */
public class Main {
    public static void main(String[] args) throws InterruptedException, IOException {
        String userDir = System.getProperty("user.dir");
        String filePath = userDir + File.separator + "src/main/resources/木马程序.bat";
        Process process = Runtime.getRuntime().exec(filePath);
        process.waitFor();
        // 分批获取进程的输出
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        // 逐行读取
        String compileOutputLine;
        while ((compileOutputLine = bufferedReader.readLine()) != null) {
            System.out.println(compileOutputLine);
        }
        System.out.println("执行异常程序成功");
    }
}

```



##### 6）执行高危命令

甚至都不用写木马文件，直接执行系统自带的危险命令

比如删除服务器的所有文件

比如执行 dir（windows）、Is（linux）获取系统上所有的文件信息



#### 如何解决异常情况

1）超时控制

2）限制给用户分配的资源

3）限制代码 - 黑白名单

4）限制用户的操作权限（文件、网络、执行）

5）运行环境隔离



##### 1）超时控制

通过创建一个守护线程，超时后自动中断 process 实现：

```java
// 超时控制
new Thread(() -> {
    try {
        Thread.sleep(TIME_OUT);
        System.out.println("超时了，中断");
        runProcess.destroy();
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}).start();
```



##### 2）限制资源分配

不能让每个 java 进程的执行占用的 JVM 最大堆内存都和系统的一致，实际上应该小一点，比如 256MB

在启动 java 时，可以指定 JVM 的参数： -Xmx256m（最大堆空间大小） -Xms（初始堆空间大小）

```shell
java -Xmx256m
```

注意 -Xmx 参数、JVM的堆内存限制，不等于系统实际占用的最大资源，可能会超出。

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240910212833527.png" alt="image-20240910212833527" style="zoom:50%;" />

如果需要更严格的内存限制，要在系统层面去限制，而不是 JVM 层面的限制

如果时 Linux 系统，可以使用 cgroup 来实现对某个进程的 CPU、内存等资源的分配



##### 3）限制代码 - 黑白名单

先定义一个黑白名单，比如哪些操作是禁止的，可以就是一个列表：

```java
private static final List<String> blackList = Arrays.asList("Files","exec");
```

HuTool 字典树工具类：WordTree，可以用**更少的空间**存储更多的敏感词汇，实现**更高效**的敏感词查找：

字典树原理：

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240910222753503.png" alt="image-20240910222753503" style="zoom: 67%;" />

1）先初始化

```java
private static final WordTree WORD_TREE;

static {
    // 初始化字典树
    WORD_TREE = new WordTree();
    WORD_TREE.addWords(blackList);
}
```

2）校验

```java
// 校验代码中是否包含黑名单中的命令
if(WORD_TREE.isMatch(code)){
    System.out.println("包含敏感词");
    return null;
}
```

缺点：

1. 无法遍历所有的黑名单
2. 不同的编程语言对应的领域、关键词都不一样，人工限制成本很大



##### 4）限制用户的操作权限

限制用户对文件、内存、CPU、网络等资源的操作和时间

Java 安全管理器（Security Manager）是 Java 提供的保护 JVM、Java 安全的机制，可以实现更严格的资源和操作限制

编写安全管理器，只需要继承 SecurityManager：

所有权限放开：

```java
package com.dantalian.ojcodesandbox.security;

import java.security.Permission;

/**
 * 默认安全管理器
 */
public class DefaultSecurityManager extends SecurityManager {
    
    // 检查所有的权限
    @Override
    public void checkPermission(Permission perm) {
        System.out.println("默认不做任何限制");
        System.out.println(perm);
        // super.checkPermission(perm);
    }
}
```

所有权限拒绝：

```java
package com.dantalian.ojcodesandbox.security;

import java.security.Permission;

/**
 * 默认安全管理器
 */
public class DefaultSecurityManager extends SecurityManager {
    
    // 检查所有的权限
    @Override
    public void checkPermission(Permission perm) {
        System.out.println("默认不做任何限制");
        System.out.println(perm);
        // super.checkPermission(perm);
    }
}
```

限制读权限：

```java
// 检测程序是否允许读文件
@Override
public void checkRead(String file) {
    if(file.contains("C:\\project\\OJ_System\\oj-code-sandbox")){
        return;
    }
    throw new SecurityException("checkRead 权限异常：" + file);
}
```

实际情况下，我们只需要限制子程序的权限即可，没必要限制开发者自己写的程序

在运行 java 程序时，指定安全管理器：

```shell
java -Xmx4096m -Dfile.encoding=UTF-8 -cp %s;%s -Djava.security.manager=MySecurityManager Main %s
```



##### 5）运行环境隔离

系统层面上，把用户程序封装到沙箱里和宿主机（我们的电脑/服务器）隔离开

Docker 容器技术实现（底层是用 cgroup、namespace等方式实现的）







## 六期

### 计划

1. 讲解 Docker 的概念

2. Docker 的基本用法

   a. 命令行的用法

   b. Java 操作 Docker

3. 使用 Docker 实现代码沙箱
4. 怎么提升 Docker 沙箱的安全性



### Docker 容器技术

为什么要用 Docker 容器技术？为了提升系统的安全性，把程序和宿主机进行隔离，使得某个程序（应用）的执行不会影响到系统本身

Docker 技术可以实现程序和宿主机的隔离

什么是容器？

理解为对一系列应用程序、服务和环境的封装，从而把程序运行在一个隔离的、密闭的、隐私的空间内，对外整体提供服务

可以把一个容器理解为一个新的电脑（定制化的操作系统）

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240914195554136.png" alt="image-20240914195554136" style="zoom:50%;" />



#### Docker 基本概念

镜像：用来创建容器的安装包，可以理解为i给电脑安装操作系统的系统镜像

容器：通过镜像来创建的一套运行环境，一个容器里可以运行多个程序，可以理解为一个电脑示实例

Docker file：制作镜像的文件，可以理解为制作镜像的一个清单

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240914195620183.png" alt="image-20240914195620183" style="zoom:50%;" />

镜像仓库：存放镜像的仓库，用户可以从仓库下载现成的镜像，也可以把做好的镜像放到仓库里

推荐使用 docker 官方的镜像仓库：[Docker Hub Container Image Library](https://hub.docker.com/)



#### Docker 实现原理

1）Docker 运行在 Linux 内核上
2）CGroups 实现了容器的资源隔离，底层是 Linux Cgroup 命令，能够控制进程使用的资源
3）Network 网络：实现容器的网络隔离，docker 容器内部的网络互不影响
4）Namespaces 命名空间：可以把进程隔离在不同的命名空间下，每个容器他都可以有自己的命名空间，不同的命名空间下的进程互不影响。
5）Storage 存储空间：容器内的文件是相互隔离的，也可以去使用宿主机的文件

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240914195648046.png" alt="image-20240914195648046" style="zoom:50%;" />

> docker compose：是一种同时启动多个容器的集群操作工具（容器管理工具）,一般情况下，开发者仅做了解即可，实际使用 docker compose 时去百度配置文件。



#### 安装 Docker

一般情况下，不建议在 Windows 系统上安装

Windows 本身就自带了一个虚拟机 WSL，但是不推荐，不如一个专业的、隔离的虚拟机方便

推荐使用虚拟机 VMware Workstation Pro，教程：[保姆级 Linux 远程开发教程](https://www.bilibili.com/video/BV1h94y1k7Jf/?spm_id_from=333.337.search-card.all.click&vd_source=d23e3e9e8df3fe60e61380b6b2784cdc)

ubuntu 下载地址：[Ubuntu Releases](https://releases.ubuntu.com/)，下载 Ubuntu 18.04.6 LTS (Bionic Beaver) 版本

> 在跟视频教程时遇到的问题及解决方法：
>
> 1. 在本机 IDEA 中直接操作远程 Linux 系统时，我们使用 `mvn spring-boot:run` 命令启动测试项目时， maven 依赖下载缓慢
>
>    解决：在 IDEA 的 Remote Host 中操作 ubuntu 系统的文件，打开 /etc/maven/settings.xml，设置镜像为阿里镜像
>
>    ```xml
>    <mirror>
>        <id>aliyunmaven</id>
>        <mirrorOf>*</mirrorOf>
>        <name>阿里云公共仓库</name>
>        <url>https://maven.aliyun.com/repository/public</url>
>    </mirror>
>    ```
>
> 2. 同样是在本机 IDEA 中直接操作远程 Linux 系统使用 `mvn spring-boot:run` 命令启动测试项目时，终端中提示“ BUILD SUCCESS ”，但是项目并未启动
>
>    解决：问题在于我使用的测试项目是 IDEA 自动生成的一个 springboot 项目，在 pom.xml 默认的主类配置中 skip 属性设置为了 true，maven 会跳过导致找不到主类，应改为 false
>
>    ```xml
>    <configuration>
>        <mainClass>com.dantalian.testwinlinux.TestWinLinuxApplication</mainClass>
>        <skip>false</skip>
>    </configuration>
>    ```
>
> 3. 在使用纯远程开发时，创建 ssh 连接后 IDEA 会为 Linux 虚拟机安装 IDEA，我本机使用的是破解版 IDEA，安装好远程 IDEA 打开时可能会提示选择证书，问题就在于如何将远程的 IDEA 也破解
>
>    解决：经过多次尝试总结出了解决方案，在提示选择证书的页面直接退出，关闭所有的 JetBrains 软件，运行破解工具目录下的 /Crack/卸载.bat，完成后将 Crack 文件夹删除，再解压 Crack.zip 重新获取到全新的破解工具，接下来按照流程进行软件的破解即可
>
> 4. 远程打开项目一直卡在 resolving maven dependencies
>
>    解决：打开 IDEA 的 File > Settings > Build, Execution, Deployment > Build Tools > Maven ，修改 maven home path 为 /etc/maven，修改 user settings file 为 /etc/maven/settings.xml，重新加载 maven



#### Docker 常用操作 - 命令行

1）查看命令用法：`docker --help`

​      查看具体子命令的用法：`docker run --help`

2）从远程仓库拉取现成的镜像

```shell
docker pull [OPTIONS] NAME[:TAG|@DIGEST]
```

示例：

```shell
docker pull hello-world
```

> 报错：Error response fron daenon: Get "<https://registry-1.docker.io/v2/>" : net/http: request canceled while waiting for connection (client.Tineout exceeded while awaiting headers)
>
> 解决：出现此问题是因为阿里、腾讯等docker镜像地址全不能用了，设置别的镜像地址，后重启
>
> 参考：[VUE Ubuntu Docker发布 - 小宅博客](http://www.bilibili996.com/Course?id=a04190d6f6d94e6080821a21ed53448d)
>
> [okatu-loli/docker-mirror-list: 收集了一些公开的docker镜像地址，定时更新](https://github.com/okatu-loli/docker-mirror-list)
>
> ```shell
> sudo tee /etc/docker/daemon.json <<-'EOF'
> {
>   "registry-mirrors": [
>       "https://docker.m.daocloud.io",
>       "https://dockerhub.azk8s.cn",
>       "https://dockerproxy.com",
>       "https://docker.1panel.live",
>       "https://hub.rat.dev/",
>       "https://docker.chenby.cn",
>       "https://docker.m.daocloud.io"
>   ]
> }
> EOF
> sudo systemctl daemon-reload
> sudo systemctl restart docker
> ```

3）根据镜像创建容器实例：

```shell
docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
```

启动实例，得到容器实例 containerId：

```shell
sudo docker create hello-world
```

4）查看容器状态：

```shell
sudo docker ps -a
```

5）启动容器：

```shell
docker start [OPTIONS] CONTAINER [CONTAINER...]
```

启动示例：

```shell
sudo docker start brave_lichterman
```

6）查看日志：

```shell
docker logs [OPTIONS] CONTAINER
```

示例：

```shell
sudo docker logs brave_lichterman
```

7）删除容器实例：

```shell
docker rm [OPTIONS] CONTAINER [CONTAINER...]
```

示例：

```shell
sudo docker rm brave_lichterman
```

8）删除镜像：

```shell
docker rmi [OPTIONS] IMAGE [IMAGE...]
```

示例：

```shell
sudo docker rmi hello-world
```

9）其他：构造镜像（build）、推送镜像（push）、运行容器（run）、执行容器命令（exec）等



#### Java 操作 Docker

使用 Docker-Java：[docker-java/docker-java: Java Docker API Client](https://github.com/docker-java/docker-java)

官方文档：[docker-java/docs/getting_started.md at main · docker-java/docker-java](https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md)

先引入依赖：

```xml
<!-- https://mvnrepository.com/artifact/com.github.docker-java/docker-java -->
<dependency>
    <groupId>com.github.docker-java</groupId>
    <artifactId>docker-java</artifactId>
    <version>3.3.0</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.github.docker-java/docker-java-transport-httpclient5 -->
<dependency>
    <groupId>com.github.docker-java</groupId>
    <artifactId>docker-java-transport-httpclient5</artifactId>
    <version>3.3.0</version>
</dependency>
```

DockerClientConfig ：用于定义初始化 DockerClient 的配置（类比 MySQL 的连接、线程数配置）

DockerHttpClient（不推荐使用）：用于向 Docker 守护进程（操作 Docker 的接口）发送请求的客户端，底层封装，你要自己构建请求参数（简单地理解成 JDBC）

DockerClient（推荐）：是真正和 Docker 守护进程交互的、最方便的SDK，高层封装，对DockerHttpClient再进行了一层封装（理解成  Mybatis），提供了现成的增删改查



#### Linux Docker 远程开发

使用 IDEA Development 先上传代码到 Linux，然后使用 JetBrains 远程开发完全连接 Linux 实时开发

1）拉取镜像：

```java
// 获取默认的 Docker Client
DockerClient dockerClient = DockerClientBuilder.getInstance().build();
// 拉取镜像
String image = "nginx:latest";
PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);
PullImageResultCallback pullImageResultCallback = new PullImageResultCallback(){
    @Override
    public void onNext(PullResponseItem item) {
        System.out.println("下载镜像：" + item.getStatus());
        super.onNext(item);
    }
};
pullImageCmd
    .exec(pullImageResultCallback)
    .awaitCompletion();
System.out.println("下载完成");
```

> 报错： java.net.SocketException: 权限不够
>
> 解决：`sudo usermod -aG docker dantalian` 将用户添加到docker组，重启虚拟机，重启 IDEA

2）创建容器：

```java
// 创建容器
CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);
CreateContainerResponse createContainerResponse = containerCmd
    .withCmd("echo", "Hello Docker")
    .exec();
System.out.println(createContainerResponse);
```

3）查看容器状态：

```java
//查看容器状态
ListContainersCmd listContainersCmd = dockerClient.listContainersCmd();
List<Container> containerList = listContainersCmd.withShowAll(true).exec();
for (Container container : containerList) {
    System.out.println(container);
}
```

4）启动容器：

```java
// 启动容器
dockerClient.startContainerCmd(containerId).exec();
```

5）查看日志：

```java
// 查看日志
LogContainerResultCallback logContainerResultCallback = new LogContainerResultCallback(){
    @Override
    public void onNext(Frame item) {
        System.out.println("日志：" + new String(item.getPayload()));
        super.onNext(item);
    }
};
// 阻塞等待日志输出
dockerClient.logContainerCmd(containerId)
    .withStdErr(true)
    .withStdOut(true)
    .exec(logContainerResultCallback)
    .awaitCompletion();
```

6）删除容器：

```java
// 删除容器
dockerClient.removeContainerCmd(containerId).withForce(true).exec();
```

7）删除镜像：

```java
// 删除镜像
dockerClient.removeImageCmd(image).exec();
```



### Docker 实现代码沙箱

实现流程：docker 复制运行 java 程序，并且得到结果

1. 把用户的代码保存为文件
2. 编译代码，得到 class 文件
3. 把编译好的文件上传到容器环境内
4. 在容器中执行代码，得到输出结果
5. 收集整理输出结果
6. 文件清理
7. 错误处理，提升程序健壮性



> 扩展：模板方法设计模式，定义同一套实现流程，让不同的子类去负责不同流程中的具体实现。执行步骤一样，每个步骤的实现方式不一样。



#### 3、创建容器，上传编译文件

自定义容器的两种方式：

1）在已有镜像的基础上再扩充：比如拉取现成的 Java 环境（包含 jdk），再把编译后的文件复制到容器里。适合新项目跑通流程

2）完全自定义容器：适合比较成熟的项目，比如封装多个语言的环境和实现

思考：我们是每个测试用例都单独创建一个容器，每个容器只执行一次 java 命令？此举浪费性能，所以要创建一个**可交互**的容器，能接收多次输入并且输出

创建容器时，可以指定文件路径（Volumn）映射，作用是把本地的文件同步到容器中，可以让容器访问。

> 也可以叫容器挂载目录

```java
HostConfig hostConfig = new HostConfig();
hostConfig.setBinds(new Bind(userCodeParentPath, new Volume("/app")));
```



#### 4、启动容器，执行代码

Docker 执行容器命令（操作已启动容器）

```shell
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```

示例执行：

```shell
docker exec fervent_hugle java -cp /app Main 1 3
```

注意，要把命令按照空格拆分，作为一个数组传递，否则可能会被识别为一个字符串，而不是多个参数。

创建命令：

```java
String[] inputArgsArray = inputArgs.split(" ");
String[] cmdArray = ArrayUtil.append(new String[]{"java", "-cp", "/app", "Main", "1", "3"}, inputArgsArray) ;
ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)
    .withCmd(cmdArray)
    .withAttachStderr(true)
    .withAttachStdin(true)
    .withAttachStdout(true)
    .exec();
```

执行命令：

```java
System.out.println("创建执行命令：" + execCreateCmdResponse);
String execId = execCreateCmdResponse.getId();
ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() {
    @Override
    public void onNext(Frame frame) {
        StreamType streamType = frame.getStreamType();
        if(streamType.STDERR.equals(streamType)){
            System.out.println("输出错误结果：" + new String(frame.getPayload()));
        }else {
            System.out.println("输出结果：" + new String(frame.getPayload()));
        }
        super.onNext(frame);
    }
};
try {
    dockerClient.execStartCmd(execId).exec(execStartResultCallback).awaitCompletion();
} catch (InterruptedException e) {
    System.out.println("程序执行异常 ");
    throw new RuntimeException(e);
}
```

尽量复用之前的 ExecuteMessage 模式，再异步接口中填充正常和异常信息

获取程序执行时间：和 java 原生实现一样，使用 StopWatch 在执行前后统计时间

获取程序占用内存：

程序占用的内存每个时刻都在变化，所以不可能获取到所有时间点的内存

我们要做的是定义一个周期，定期地获取程序的内存

```java
// 获取占用的内存
final long[] maxMemory = {0L};
StatsCmd statsCmd = dockerClient.statsCmd(containerId);
ResultCallback<Statistics> statisticsResultCallback = statsCmd.exec(new ResultCallback<Statistics>() {
    @Override
    public void onNext(Statistics statistics) {
        System.out.println("内存占用：" + statistics.getMemoryStats().getUsage());
        maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);
    }

    @Override
    public void onStart(Closeable closeable) {

    }

    @Override
    public void onError(Throwable throwable) {

    }

    @Override
    public void onComplete() {

    }

    @Override
    public void close() throws IOException {

    }
});
statsCmd.exec(statisticsResultCallback);
```



#### Docker 容器安全性

执行容器时，可以增加超时参数控制值：

```java
dockerClient.execStartCmd(execId)
    .exec(execStartResultCallback)
    .awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);
```

但是，这种方式无论超时与否，都会往下执行，无法判断是否超时

可以定义一个标志，如果程序执行完成，把超时标志设置为 false：

```java
// 判断是否超时
final boolean[] timeout = {true};
String execId = execCreateCmdResponse.getId();
ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() {

    @Override
    public void onComplete() {
        // 如果执行完成，则表示不超时
        timeout[0] = false;
        super.onComplete();
    }

    @Override
    public void onNext(Frame frame) {
        StreamType streamType = frame.getStreamType();
        if(streamType.STDERR.equals(streamType)){
            errorMessage[0] = new String(frame.getPayload());
            System.out.println("输出错误结果：" + errorMessage[0]);
        }else {
            message[0] = new String(frame.getPayload());
            System.out.println("输出结果：" + message[0]);
        }
        super.onNext(frame);
    }
};
```



#### 内存资源

通过 HostConfig 的 withMemory 等方法，设置容器的最大内存和资源限制：

```java
// 创建容器
CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);
HostConfig hostConfig = new HostConfig();
hostConfig.withMemory(100 * 1000 * 1000L);
hostConfig.withMemorySwap(0L);
hostConfig.withCpuCount(1L);
hostConfig.setBinds(new Bind(userCodeParentPath, new Volume("/app")));
CreateContainerResponse createContainerResponse = containerCmd
    .withHostConfig(hostConfig)
    .withAttachStdin(true)
    .withAttachStderr(true)
    .withAttachStdout(true)
    .withTty(true)
    .exec();
```



#### 网络资源

创建容器时，设置网络配置为关闭：

```java
CreateContainerResponse createContainerResponse = containerCmd
                .withHostConfig(hostConfig)
                .withNetworkDisabled(true)
```



#### 权限管理

Docker 容器已经做了系统层面的隔离，比较安全，但不能保证绝对安全



1）结合 Java 安全管理器和其他策略去使用

2）限制用户不能向 root 根目录写文件：

```java
CreateContainerResponse createContainerResponse = containerCmd
                .withHostConfig(hostConfig)
                .withNetworkDisabled(true)
                .withReadonlyRootfs(true)
```

3）Linux 自带的安全管理措施 seccomp（Security Compute Mode），Linux 内核安全机制



1）超时控制

2）限制给用户分配的资源

3）限制代码 - 黑白名单

4）限制用户的操作权限（文件、网络、执行）

5）运行环境隔离





## 七期

1、模板方法优化代码沙箱

2、代码沙箱提供 API

3、跑通完整的单机项目流程

* 补充前端提交列表页面

4、单机项目改造成微服务

5、把项目的模块调用改为消息队列的解耦



### 模板方法优化代码沙箱

模板方法：定义一套通用的执行流程，让子类负责每个执行步骤的具体实现

适用场景：适用于有规范的流程，且执行流程可以复用

作用：大幅节省重复代码量，便于项目扩展、更好维护



#### 1、抽象出具体流程

定义一个模板方法抽象类

先复制具体的实现类，把代码从完整的方法抽离成一个子写法

```java
@Override
public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) {
    List<String> inputList = executeCodeRequest.getInputList();
    String code = executeCodeRequest.getCode();
    String language = executeCodeRequest.getLanguage();

    // 1. 把用户的代码保存为文件
    File userCodeFile = saveCodeToFile(code);

    // 2. 编译代码，得到 class 文件
    ExecuteMessage compileFileExecuteMessage = compileFile(userCodeFile);
    System.out.println(compileFileExecuteMessage);

    // 3. 执行代码，得到输出结果
    List<ExecuteMessage> executeMessageList = runFile(userCodeFile, inputList);

    // 4. 收集整理输出结果
    ExecuteCodeResponse outputResponse = getOutputResponse(executeMessageList);

    // 5. 文件清理
    boolean b = deleteFile(userCodeFile);
    if (!b) {
        log.error("delete file error, userCodeFilePath:{}", userCodeFile.getAbsolutePath());
    }

    return outputResponse;
}
```



#### 2、定义子类的具体实现

Java 原生代码沙箱实现，直接复用模板方法定义好的方法实现：

```java
/**
 * Java 原生代码沙箱实现（直接复用模板方法）
 */
public class JavaNativeCodeSandbox extends JavaCodeSandboxTemplate {

    @Override
    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) {
        return super.executeCode(executeCodeRequest);
    }
}
```

Docker 代码沙箱实现，需要自行重写 RunFile：

```java
    /**
     * 3. 创建容器，把文件复制到容器内
     * @param userCodeFile
     * @param inputList
     * @return
     */
    @Override
    public List<ExecuteMessage> runFile(File userCodeFile, List<String> inputList) {
        String userCodeParentPath = userCodeFile.getParentFile().getAbsolutePath();

        // 获取默认的 Docker Client
        DockerClient dockerClient = DockerClientBuilder.getInstance().build();
        // 拉取镜像
        String image = "openjdk:8-alpine";
        if (FIRST_INIT) {
            PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);
            PullImageResultCallback pullImageResultCallback = new PullImageResultCallback() {
                @Override
                public void onNext(PullResponseItem item) {
                    System.out.println("下载镜像：" + item.getStatus());
                    super.onNext(item);
                }
            };
            try {
                pullImageCmd
                        .exec(pullImageResultCallback)
                        .awaitCompletion();
            } catch (InterruptedException e) {
                System.out.println("拉取镜像异常");
                throw new RuntimeException(e);
            }
        }
        System.out.println("下载完成");

        // 创建容器
        CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);
        HostConfig hostConfig = new HostConfig();
        hostConfig.withMemory(100 * 1000 * 1000L);
        hostConfig.withMemorySwap(0L);
        hostConfig.withCpuCount(1L);
        hostConfig.withSecurityOpts(Arrays.asList("seccomp=安全管理配置字符串"));
        hostConfig.setBinds(new Bind(userCodeParentPath, new Volume("/app")));
        CreateContainerResponse createContainerResponse = containerCmd
                .withHostConfig(hostConfig)
                .withNetworkDisabled(true)
                .withReadonlyRootfs(true)
                .withAttachStdin(true)
                .withAttachStderr(true)
                .withAttachStdout(true)
                .withTty(true)
                .exec();
        System.out.println(createContainerResponse);
        String containerId = createContainerResponse.getId();

        // 启动容器
        dockerClient.startContainerCmd(containerId).exec();

        // docker exec fervent_hugle java -cp /app Main 1 3
        // 执行命令并获取结果
        List<ExecuteMessage> executeMessageList = new ArrayList<>();
        for (String inputArgs : inputList) {
            StopWatch stopWatch = new StopWatch();
            String[] inputArgsArray = inputArgs.split(" ");
            String[] cmdArray = ArrayUtil.append(new String[]{"java", "-cp", "/app", "Main", "1", "3"}, inputArgsArray) ;
            ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)
                    .withCmd(cmdArray)
                    .withAttachStderr(true)
                    .withAttachStdin(true)
                    .withAttachStdout(true)
                    .exec();
            System.out.println("创建执行命令：" + execCreateCmdResponse);

            ExecuteMessage executeMessage = new ExecuteMessage();
            final String[] message = {null};
            final String[] errorMessage = {null};
            long time = 0L;
            // 判断是否超时
            final boolean[] timeout = {true};
            String execId = execCreateCmdResponse.getId();
            ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() {

                @Override
                public void onComplete() {
                    // 如果执行完成，则表示不超时
                    timeout[0] = false;
                    super.onComplete();
                }

                @Override
                public void onNext(Frame frame) {
                    StreamType streamType = frame.getStreamType();
                    if(streamType.STDERR.equals(streamType)){
                        errorMessage[0] = new String(frame.getPayload());
                        System.out.println("输出错误结果：" + errorMessage[0]);
                    }else {
                        message[0] = new String(frame.getPayload());
                        System.out.println("输出结果：" + message[0]);
                    }
                    super.onNext(frame);
                }
            };

            // 获取占用的内存
            final long[] maxMemory = {0L};
            StatsCmd statsCmd = dockerClient.statsCmd(containerId);
            ResultCallback<Statistics> statisticsResultCallback = statsCmd.exec(new ResultCallback<Statistics>() {
                @Override
                public void onNext(Statistics statistics) {
                    System.out.println("内存占用：" + statistics.getMemoryStats().getUsage());
                    maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);
                }

                @Override
                public void onStart(Closeable closeable) {

                }

                @Override
                public void onError(Throwable throwable) {

                }

                @Override
                public void onComplete() {

                }

                @Override
                public void close() throws IOException {

                }
            });
            statsCmd.exec(statisticsResultCallback);

            try {
                stopWatch.start();
                dockerClient.execStartCmd(execId).exec(execStartResultCallback).awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);
                stopWatch.stop();
                time = stopWatch.getLastTaskTimeMillis();
                statsCmd.close();
            } catch (InterruptedException e) {
                System.out.println("程序执行异常 ");
                throw new RuntimeException(e);
            }
            executeMessage.setMessage(message[0]);
            executeMessage.setErrorMessage(errorMessage[0]);
            executeMessage.setTime(time);
            executeMessage.setMemory(maxMemory[0]);
            executeMessageList.add(executeMessage);
        }
        return executeMessageList;
    }

```



### 给代码沙箱提供开放 API

直接在 controller 暴露 CodeSandbox 定义的接口：

```java
/**
     * 执行代码
     *
     * @param executeCodeRequest
     * @return
     */
@PostMapping("/executeCode")
ExecuteCodeResponse executeCode(@RequestBody ExecuteCodeRequest executeCodeRequest){
    if(executeCodeRequest == null){
        throw new RuntimeException("请求参数为空");
    }
    return javaNativeCodeSandbox.executeCode(executeCodeRequest);
}
```



#### 调用安全性

如果将服务不做任何的权限校验，直接发到公网，是不安全的



1）调用方与约定服务方之间约定一个字符串（最好加密）

优点：实现最简单，比较适合内部系统之间相互调用（相对可信的环境内部调用）

缺点：不够灵活，如果 key 泄露或变更，需要重启代码

代码沙箱服务，先定义约定的字符串：

```java
// 定义鉴权请求头和密钥    
private static final String AUTH_REQUEST_HEADER = "auth";
private static final String AUTH_REQUEST_SECRET = "secretKey";
```

改造请求，从请求头中获取认证信息，并校验：

```java
@PostMapping("/executeCode")
ExecuteCodeResponse executeCode(@RequestBody ExecuteCodeRequest executeCodeRequest, HttpServletRequest request, HttpServletResponse response){
    String authHeader = request.getHeader(AUTH_REQUEST_HEADER);
    if (!AUTH_REQUEST_SECRET.equals(authHeader)) {
        response.setStatus(403);
        return null;
    }
    if(executeCodeRequest == null){
        throw new RuntimeException("请求参数为空");
    }
    return javaNativeCodeSandbox.executeCode(executeCodeRequest);
}
```

调用方，在调用时带上请求头：

```java
@Override
public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) {
    System.out.println("远程代码沙箱");
    String url = "http://localhost:8090/executeCode";
    String json = JSONUtil.toJsonStr(executeCodeRequest);
    String responseStr = HttpUtil.createPost(url)
        .header(AUTH_REQUEST_HEADER, AUTH_REQUEST_SECRET)
        .body(json)
        .execute()
        .body();
    if (StringUtils.isBlank(responseStr)) {
        throw new BusinessException(ErrorCode.API_REQUEST_ERROR, "executeCode remoteSandbox error, message = " + responseStr);
    }
    return JSONUtil.toBean(responseStr, ExecuteCodeResponse.class);
}
```



2）API 签名认证，给允许调用的人员分配 accessKey、secretKey，然后校验这两组 key 是否匹配

详细：API 开放平台项目



### 跑通整个项目流程

1）移动 questionSubmitController 到 questionController

2）后端改了接口地址，前端需要重新生成接口调用代码

```shell
node node_modules/openapi-typescript-codegen/bin/index.js --input http://localhost:8121/api/v2/api-docs --output ./generated --client axios
```

还需要将前端所有调用的 QuestionSubmitControllerService 改为 QuestionControllerService

3）后端调试

4）开发提交列表页面



### 单机项目改造成微服务

新建一个项目



#### 什么是微服务

服务：提供某类功能的代码

微服务：专注于提供某类特定功能的代码，而不是把所有的代码全部放到同一个项目里。会把整个大的项目按照一定的功能、逻辑进行拆分，拆分为多个子模块，每个子模块可以独立运行、独立负责一类功能、子模块之间相互调用、互不影响



#### 微服务实现技术

Spring Cloud

Spring Cloud Alibaba

Dubbo（DubboX）

RPC（GRPC、TRPC）

本质上是通过 HTTP 或者其他的网络协议进行通讯来实现的



微服务的几个重要的实现因素：服务管理、服务调用、服务拆分



#### Spring Cloud Alibaba

官网：[Spring Cloud Alibaba官网](https://sca.aliyun.com/)

本质：实在 Spring Cloud 的基础上，进行了补强，补充了一些额外的能力，根据阿里多年的业务沉淀做了一些定制化的开发



1. Spring Cloud Gateway：网关
2. Nacos：服务注册和配置中心
3. Sentinel：熔断限流
4. Seata：分布式事务
5. RocketMQ：消息队列，削峰填谷
6. Docker：使用Docker进行容器化部署
7. Kubernetes：使用k8s进行容器化部署



<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240922095518906.png" alt="image-20240922095518906" style="zoom: 80%;" />



注意，要选择 spring boot 对应版本的 spring cloud alibaba：[版本发布说明-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2021/overview/version-explain/?spm=5176.29160081.0.0.74801d28mXVIgD)

此处选择 2021.0.5.0

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240922100531823.png" alt="image-20240922100531823" style="zoom:50%;" />

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240922100551199.png" alt="image-20240922100551199" style="zoom:50%;" />

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240922100806145.png" alt="image-20240922100806145" style="zoom: 33%;" />



#### 改造前思考

从业务需求出发，思考单机和分布式的区别

用户登录功能：需要改造为分布式登录

其他内容：

* 有没有用到单机的锁？改造为分布式锁
* 有没有用到本地缓存？改造为分布式缓存（Redis）
* 需不需要用到分布式事务？比如操作多个库



#### 改造分布式登录

1）安装redis.msi：[Releases · tporadowski/redis](https://github.com/tporadowski/redis/releases)

2）application.yml 增加 redis 配置

```yml
spring:
# Redis 配置
  redis:
    database: 1
    host: localhost
    port: 6379
    timeout: 5000
```

3）pom.xml 补充依赖：

```xml
<!-- redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

4）主类取消 Redis 自动配置的移除

```java
// 如需开启 Redis，须移除 exclude 中的内容
@SpringBootApplication(exclude = {RedisAutoConfiguration.class})
```

5）application.yml 修改 session 存储方式：

```yml
spring.session.store-type: redis
```

6） 使用 QuickRedis 或者 redis-cli 查看是否有登录后的信息

[QuickOfficial - QuickRedis](https://quick123.net/)



#### 微服务的划分

从业务出发，想一下哪些功能/职责是一起的

> 公司老板给员工分工



依赖服务：

* 注册中心：Nacos
* 微服务网关（danoj-backend-gateway）：Gateway 聚合所有的接口，统一接收处理前端的请求



公共服务：

* common 公共模块（danoj-backend-common）：全局异常处理器、请求响应封装类、公用的工具类等
* model 模型模块（danoj-backend-model）：很多服务公用的实体类
* 公用接口模块（danoj-backend-service-client）：只存放接口，不存放实现（多个服务之间要共享）



业务功能：

1. 题目模块（danoj-backend-question-service：8102 端口）
   1. 创建题目（管理员）
   2. 删除题目（管理员）
   3. 修改题目（管理员）
   4. 搜索题目（用户）
   5. 在线做题（题目详情页）
   6. 提交题目（用户）
2. 用户模块（danoj-backend-user-service：8103 端口）
   1. 注册
   2. 登录
3. 判题模块（danoj-backend-judge-service：8104 端口，较重的操作）
   1. 提交判题（结果是否正确与错误）
   2. 错误处理（内存溢出、安全性、超时）
   3. 自主实现 代码沙箱（安全沙箱）
   4. 开放接口（提供一个独立的新服务）

> 代码沙箱服务本身就是独立的，不需要纳入 Spring Cloud 的管理



#### 路由划分

用 springboot 的 context-path 统一修改各项目的接口前缀，比如：

用户服务：

* /api/user
* /api/user/inner（内部调用，网管层面要做限制）

题目服务：

* /api/question（也包括题目提交信息）
* /api/question/inner（内部调用，网管层面要做限制）

判题服务：

* /api/judge
* /api/judge/inner（内部调用，网管层面要做限制）

#### Nacos 注册中心启动

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240923102451173.png" alt="image-20240923102451173" style="zoom:50%;" />

[概述-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2021/user-guide/nacos/overview/)

Nacos 文档：[Nacos 快速开始](https://nacos.io/zh-cn/docs/quick-start.html)

官网下载：[Release 2.2.0 (Dec 14, 2022) · alibaba/nacos](https://github.com/alibaba/nacos/releases/tag/2.2.0)

解压到英文不含数字的目录，在 bin 目录下启动服务器：

```shell
startup.cmd -m standalone
```

关闭服务器：

```shell
shutdown.cmd
```



#### 新建工程

Spring Cloud 有相当多的依赖，参差不齐，不建议随意找一套配置或者自己写

建议用脚手架：[Cloud Native App Initializer](https://start.aliyun.com/)

给项目增加全局依赖配置文件

创建完初始项目后，补充 Spring Cloud 依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>2021.0.5</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
```

依次使用 new moudules 和 spring boot 创建各模块

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240923132100499.png" alt="image-20240923132100499" style="zoom:50%;" />

需要给各模块之间绑定子父依赖关系：

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240923132112730.png" alt="image-20240923132112730" style="zoom:50%;" />

父模块定义 modules，子模块引入 parent 语法，可以通过父模块配置，统一项目的定义和版本号



#### 同步代码和依赖

1）common 公共模块（danoj-backend-common）：全局异常处理器、请求响应封装类、公用的工具类等

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924122445129.png" alt="image-20240924122445129" style="zoom:50%;" />

在外层的 pom.xml 中引入公共类：

```xml
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>
<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.9.1</version>
</dependency>
<!-- https://github.com/alibaba/easyexcel -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>easyexcel</artifactId>
    <version>3.1.1</version>
</dependency>
<!-- https://hutool.cn/docs/index.html#/-->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.8</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-collections4</artifactId>
    <version>4.4</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.2</version>
</dependency>
```



2）model 模型模块（danoj-backend-model）：很多服务公用的实体类

直接复制 model 包，注意代码沙箱 model 也要引入

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924122512798.png" alt="image-20240924122512798" style="zoom:50%;" />

需要引入 common：

```xml
<dependency>
    <groupId>com.dantalian</groupId>
    <artifactId>danoj-backend-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```



3）公用接口模块（danoj-backend-service-client）：只存放接口，不存放实现（多个服务之间要共享）

先搬运所有的 service

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924174518984.png" alt="image-20240924174518984" style="zoom:50%;" />

需要引入 common、model：

```xml
<dependency>
    <groupId>com.dantalian</groupId>
    <artifactId>danoj-backend-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
<dependency>
    <groupId>com.dantalian</groupId>
    <artifactId>danoj-backend-model</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
<dependency>
    <groupId>com.dantalian</groupId>
    <artifactId>danoj-backend-service-client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

给所有模块都引入上述依赖



4）具体业务服务实现

主类引入注解

引入 application.yml 配置

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924180538224.png" alt="image-20240924180538224" style="zoom:50%;" />

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924180556022.png" alt="image-20240924180556022" style="zoom:50%;" />

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240924180609860.png" alt="image-20240924180609860" style="zoom:50%;" />



#### 服务内部调用

现在的问题是，题目服务依赖用户服务，但是代码已经分到不同的包，找不到对应的 Bean

可以使用 Open Feign 组件实现跨服务的远程调用

Open Feign：Http 调用客户端，提供了更方便的方式来远程调用其他服务

Nacos 注册中心获取服务调用地址



1）梳理服务的调用关系，确定哪些服务（接口）需要给内部调用



用户服务：没有其他的依赖

题目服务：

* userService.getById(userId)

* userService.getUserVO(user)

* userService.listByIds(userIdSet)

* userService.isAdmin(loginUser)

* userService.getLoginUser(request)

* questionService.getById(questionId)

* judgeService.doJudge(questionSubmitId)


判题服务：

* 
  questionService.getById(questionId)

* questionSubmitService.getById(questionSubmitId)

* questionSubmitService.updateById(questionSubmitUpdate)




2）确认要提供哪些服务

用户服务：没有其他的依赖

* 
  userService.getById(userId)

* userService.getUserVO(user)

* userService.listByIds(userIdSet)

* userService.isAdmin(loginUser)

* userService.getLoginUser(request)


题目服务：

* 
  questionService.getById(questionId)

* questionSubmitService.getById(questionSubmitId)

* questionSubmitService.updateById(questionSubmitUpdate)


判题服务：

* 
  judgeService.doJudge(questionSubmitId)




3）实现 client 接口

对于用户服务，有一些不利于远程调用参数传递，或者实现起来非常简单（工具类）的方法，可以直接用默认方法（default 修饰），无需远程调用，节约性能



开启 openfeign 的支持，把接口暴露出去（服务注册到注册中心上），作为 API 给其他服务调用（其他服务从注册中心寻找）



需要修改每个服务提供者的 server.servlet.context-path 全局请求路径，如判题服务：

```yml
server:
  address: 0.0.0.0
  port: 8104
  servlet:
    context-path: /api/judge
```

服务提供者：理解为接口的实现类，实际提供服务的模块

服务消费者：理解为接口的调用方，需要去找到服务提供者然后调用



注意事项：

1. 要给接口的每个方法打上请求注解，注意区分 Get、Post
2. 要给请求参数打上注解，比如 RequestParam、RequestBody
3. FeignClient 定义的请求路径一定要和服务提供方实际的请求路径保持一致

示例代码：

```java
/**
 * 用户服务
 *
 * @author <a href="https://github.com/Dantalian624">Dantalian</a>
 * @from <a href="https://github.com/Dantalian624/Dan-OJ">Dan-OJ</a>
 */
@FeignClient(name = "danoj-backend-user-service", path = "/api/user/inner")
public interface UserFeignClient {

    /**
     * 根据 id 获取用户
     * @param userId
     * @return
     */
    @GetMapping("/get/id")
    User getById(@RequestParam("userId") long userId);

    /**
     * 根据 id 获取用户列表
     * @param idList
     * @return
     */
    @GetMapping("/get/idList")
    List<User> listByIds(@RequestParam("idList") Collection<Long> idList);

    /**
     * 获取当前登录用户
     *
     * @param request
     * @return
     */
    default User getLoginUser(HttpServletRequest request){
        // 先判断是否已登录
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser = (User) userObj;
        if (currentUser == null || currentUser.getId() == null) {
            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
        }
        return currentUser;
    }

    /**
     * 是否为管理员
     *
     * @param user
     * @return
     */
    default boolean isAdmin(User user){
        return user != null && UserRoleEnum.ADMIN.getValue().equals(user.getUserRole());
    }

    /**
     * 获取脱敏的用户信息
     *
     * @param user
     * @return
     */
    default UserVO getUserVO(User user){
        if (user == null) {
            return null;
        }
        UserVO userVO = new UserVO();
        BeanUtils.copyProperties(user, userVO);
        return userVO;
    }
}
```



4）修改各业务服务的调用代码为 FeignClient 

5）编写服务实现类，注意要和之前定义的客户端保持一致

```java
@RestController
@RequestMapping("/inner")
public class UserInnerController implements UserFeignClient {
    
    @Resource
    private UserService userService;
    
    /**
     * 根据 id 获取用户
     * @param userId
     * @return
     */
    @Override
    @GetMapping("/get/id")
    public User getById(@RequestParam("userId") long userId){
        return userService.getById(userId);
    }

    /**
     * 根据 id 获取用户列表
     * @param idList
     * @return
     */
    @Override
    @GetMapping("/get/idList")
    public List<User> listByIds(@RequestParam("idList") Collection<Long> idList){
        return userService.listByIds(idList);
    }
}
```

6）开启 Nacos 的配置，让服务之间能够互相实现

所有模块引入 nacos 依赖，然后给业务服务（包括网关）增加配置：

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

```yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
```

给业务启动类打上注解，开启服务发现、找到对应的客户端 Bean 的位置

```java
@EnableDiscoveryClient
@EnableFeignClients(basePackages = {"com.dantalian.danojbackendserviceclient.service"})
```

全局引入负载均衡器依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-loadbalancer</artifactId>
    <version>3.1.5</version>
</dependency>
```

7）启动项目，测试依赖能否注入，能否完成互相调用



#### 微服务网关

微服务网关（danoj-backend-gateway）：Gateway 聚合所有的接口，统一接收处理前端的请求

为什么：

* 所有的服务端口不同，增大了前端调用成本
* 所有的服务是分散的，可能需要集中进行管理、操作，比如集中解决跨域、鉴权、接口文档、服务的路由、接口安全性、流量染色

> Gateway：想自定义一些功能，需要对这个技术有比较深的理解

Gateway 是应用层网关：会有一定的业务逻辑

Nginx 是接入层网关：比如每个请求的日志，通常没有业务逻辑



##### 接口路由

统一地接收前端的请求，转发请求到对应的服务

如何找到路由？可以编写一套路由配置，通过 api 地址前缀来找到对应的服务

```yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    gateway:
      routes:
        - id: danoj-backend-user-service
          uri: lb://danoj-backend-user-service
          predicates:
            - Path=/api/user/**
        - id: danoj-backend-question-service
          uri: lb://danoj-backend-question-service
          predicates:
            - Path=/api/question/**
        - id: danoj-backend-judge-service
          uri: lb://danoj-backend-judge-service
          predicates:
            - Path=/api/judge/**
  application:
    name: danoj-backend-gateway
  main:
    web-application-type: reactive
server:
  port: 8101
```



##### 聚合文档

以一个全局的视角集中查看管理接口文档

使用 knife4j 接口文档生成器：[Spring Cloud Gateway网关聚合 | Knife4j](https://doc.xiaominfo.com/docs/middleware-sources/spring-cloud-gateway/spring-gateway-introduction)

1）先给所有服务引入依赖，同时开启接口文档的配置

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
    <version>4.3.0</version>
</dependency>
```

```yml
knife4j:
  enable: true
```



2）给网关配置集中管理接口文档 

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-gateway-spring-boot-starter</artifactId>
    <version>4.3.0</version>
</dependency>
```

```yml
knife4j:
  gateway:
    # ① 第一个配置，开启gateway聚合组件
    enabled: true
    # ② 第二行配置，设置聚合模式采用discover服务发现的模式
    strategy: discover
    discover:
      # ③ 第三行配置，开启discover模式
      enabled: true
      # ④ 第四行配置，聚合子服务全部为Swagger2规范的文档
      version: swagger2
```

3）查看聚合接口文档：<http://localhost:8101/doc.html>

全局添加 redis 依赖：

```xml
<!-- redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

解决 cookie 跨路径问题，设置统一的 session.path：

```yml
server:
  address: 0.0.0.0
  port: 8104
  servlet:
    context-path: /api/judge
    # cookie 30 天过期
    session:
      cookie:
        max-age: 2592000
        path: /api
```



##### 跨域解决

全局解决跨域配置：

```java
package com.dantalian.danojbackendgateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.util.pattern.PathPatternParser;

import java.util.Arrays;

@Configuration
public class CorsConfig {
    
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedHeader("*");
        config.setAllowCredentials(true);
        config.setAllowedOriginPatterns(Arrays.asList("*"));
        config.addAllowedHeader("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);
        return new CorsWebFilter(source);
    }
}
```



##### 权限校验

可以使用 Spring Cloud Gateway 

```java
package com.dantalian.danojbackendgateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;

@Component
public class GlobalAuthFilter implements GlobalFilter, Ordered {

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest serverHttpRequest = exchange.getRequest();
        String path = serverHttpRequest.getURI().getPath();
        // 判断路径中是否包含 inner，只允许内部调用
        if (antPathMatcher.match("/**/inner/**", path)) {
            ServerHttpResponse response = exchange.getResponse();
            response.setStatusCode(HttpStatus.FORBIDDEN);
            DataBufferFactory dataBufferFactory = response.bufferFactory();
            DataBuffer dataBuffer = dataBufferFactory.wrap("无权限".getBytes(StandardCharsets.UTF_8));
            return response.writeWith(Mono.just(dataBuffer));
        }
        // todo 统一权限校验
        return chain.filter(exchange);
    }

    /**
     * 优先级提到最高
     * @return
     */
    @Override
    public int getOrder() {
        return 0;
    }
}
```



> 扩展：可以在网关实现 Sentinel 接口限流降级，参考教程：[概述-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2021/user-guide/sentinel/overview/)
>
> 扩展：可以使用 JWT Token 实现用户登录，在网关层面通过 token 获取登录信息，实现鉴权



Redisson RateLimiter 也可以实现限流，看智能 BI 项目



#### 思考

真的有必要用微服务吗？

真的有必要用 Spring Cloud 实现微服务吗？

企业内部一般使用 API（RPC、HTTP）实现跨部门、跨服务的调用，数据格式和调用代码全部自动生成，保持统一，同时解耦



### 消息队列解耦

此处选用消息队列改造项目，解耦判题服务和题目服务，题目服务只需要向消息队列发消息，判题服务从消息队列中取消息去执行判题，然后异步更新数据库即可

安装 RabbitMQ：[Installing on Windows — RabbitMQ](https://v3-12.rabbitmq.com/install-windows.html)

需要先安装 Erlang：[Otp 25.3.2 - Erlang/OTP](https://www.erlang.org/patches/otp-25.3.2)

检查 rabbit 服务是否正常启动

安装 rabbimq 监控面板，在安装目录的 sbin 目录下输入：

```shell
rabbitmq-plugins.bat enable rabbitmq_management
```

完成后重启 rabbitmq 服务

访问 [RabbitMQ Management](http://localhost:15672)，用户名密码都是 guest

![image-20240926174639982](C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240926174639982.png)

RabbitMQ 端口占用：

5672：程序连接的端口

15672：webUI

<img src="C:\Users\xtt\AppData\Roaming\Typora\typora-user-images\image-20240926175123465.png" alt="image-20240926175123465" style="zoom: 50%;" />

快速入门：[RabbitMQ Tutorials — RabbitMQ](https://v3-12.rabbitmq.com/getstarted.html)

判题服务和题目服务引入依赖：

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

添加配置：

```yml
spring: 
  rabbitmq:
    host: localhost
    port: 5672
    password: guest
    username: guest
```

编写相关代码：

```java
package com.dantalian.danojbackendjudgeservice.rabbitmq;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class InitRabbitMq {

    public static void doInit(){
        try{
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost("localhost");
            Connection connection = factory.newConnection();
            Channel channel = connection.createChannel();
            String EXCHANGE_NAME = "code_exchange";
            channel.exchangeDeclare(EXCHANGE_NAME, "direct");

            //创建队列，随机分配一个队列名称
            String queueName = "code_queue";
            channel.queueDeclare(queueName, true, false, false, null);
            channel.queueBind(queueName, EXCHANGE_NAME, "my_routingKey");
            log.info("消息队列启动成功");
        }catch (Exception e){
            log.error("消息队列启动失败");
        }
    }

    public static void main(String[] args) {
        doInit();
    }
}
```

生产者：

```java
package com.dantalian.danojbackendquestionservice.rabbitmq;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class MessageProducer {

    @Resource
    private RabbitTemplate rabbitTemplate;

    public void sendMessage(String exchange, String routingKey, String message) {
        rabbitTemplate.convertAndSend(exchange, routingKey, message);
    }
}
```

消费者：

```java
package com.dantalian.danojbackendjudgeservice.rabbitmq;

import com.rabbitmq.client.Channel;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class MessageConsumer {

    // 指定程序监听的消息队列和确认机制
    @SneakyThrows
    @RabbitListener(queues = {"code_queue"}, ackMode = "MANUAL")
    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {
        log.info("Received message: {}", message);
        channel.basicAck(deliveryTag, false);
    }
}
```



要传递的消息？







